
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Sep 12 04:09:00 CEST 2022
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Sep 12 04:09:00 CEST 2022
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\164\000\002\002\004\000\002\062\002\000\002\002" +
    "\004\000\002\003\003\000\002\004\002\000\002\005\007" +
    "\000\002\005\003\000\002\006\003\000\002\006\003\000" +
    "\002\006\003\000\002\007\004\000\002\007\003\000\002" +
    "\010\016\000\002\010\003\000\002\011\003\000\002\011" +
    "\003\000\002\012\003\000\002\012\003\000\002\012\003" +
    "\000\002\013\004\000\002\013\003\000\002\015\003\000" +
    "\002\015\003\000\002\015\003\000\002\025\004\000\002" +
    "\025\003\000\002\025\003\000\002\025\003\000\002\014" +
    "\007\000\002\014\003\000\002\016\005\000\002\016\003" +
    "\000\002\016\003\000\002\017\004\000\002\017\003\000" +
    "\002\021\003\000\002\021\003\000\002\022\003\000\002" +
    "\022\003\000\002\063\002\000\002\034\022\000\002\064" +
    "\002\000\002\065\002\000\002\035\025\000\002\036\003" +
    "\000\002\036\003\000\002\020\004\000\002\020\003\000" +
    "\002\023\004\000\002\023\003\000\002\066\002\000\002" +
    "\067\002\000\002\024\017\000\002\026\005\000\002\026" +
    "\005\000\002\026\003\000\002\026\003\000\002\026\003" +
    "\000\002\026\003\000\002\026\003\000\002\026\003\000" +
    "\002\026\003\000\002\027\005\000\002\027\003\000\002" +
    "\030\005\000\002\030\005\000\002\030\003\000\002\031" +
    "\004\000\002\031\003\000\002\032\005\000\002\032\005" +
    "\000\002\033\006\000\002\041\003\000\002\041\003\000" +
    "\002\070\002\000\002\042\007\000\002\060\003\000\002" +
    "\037\003\000\002\071\002\000\002\040\007\000\002\072" +
    "\002\000\002\061\005\000\002\045\003\000\002\045\003" +
    "\000\002\045\003\000\002\045\003\000\002\045\003\000" +
    "\002\046\003\000\002\046\003\000\002\046\003\000\002" +
    "\046\003\000\002\046\003\000\002\046\003\000\002\047" +
    "\004\000\002\047\003\000\002\050\004\000\002\050\003" +
    "\000\002\073\002\000\002\051\014\000\002\074\002\000" +
    "\002\052\014\000\002\054\005\000\002\054\003\000\002" +
    "\053\005\000\002\053\003\000\002\075\002\000\002\055" +
    "\016\000\002\076\002\000\002\056\016\000\002\043\003" +
    "\000\002\043\003\000\002\043\003\000\002\077\002\000" +
    "\002\044\010\000\002\100\002\000\002\057\006" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\371\000\004\011\000\001\002\000\004\002\373\001" +
    "\002\000\004\011\010\001\002\000\004\002\uffff\001\002" +
    "\000\004\002\ufffe\001\002\000\004\024\011\001\002\000" +
    "\004\052\uffcf\001\002\000\004\052\013\001\002\000\014" +
    "\027\ufffd\041\ufffd\042\ufffd\045\015\050\ufffd\001\002\000" +
    "\012\027\ufffd\041\ufffd\042\031\050\ufffd\001\002\000\014" +
    "\024\020\027\ufffd\041\ufffd\042\ufffd\050\ufffd\001\002\000" +
    "\012\027\ufff6\041\ufff6\042\ufff6\050\ufff6\001\002\000\012" +
    "\027\ufff7\041\ufff7\042\ufff7\050\ufff7\001\002\000\004\055" +
    "\022\001\002\000\012\027\ufffb\041\ufffb\042\ufffb\050\ufffb" +
    "\001\002\000\010\031\026\035\024\047\023\001\002\000" +
    "\012\034\ufff8\043\ufff8\052\ufff8\053\ufff8\001\002\000\012" +
    "\034\ufff9\043\ufff9\052\ufff9\053\ufff9\001\002\000\004\053" +
    "\027\001\002\000\012\034\ufffa\043\ufffa\052\ufffa\053\ufffa" +
    "\001\002\000\014\024\020\027\ufffd\041\ufffd\042\ufffd\050" +
    "\ufffd\001\002\000\012\027\ufffc\041\ufffc\042\ufffc\050\ufffc" +
    "\001\002\000\012\024\356\027\ufffd\041\ufffd\050\ufffd\001" +
    "\002\000\010\027\035\041\ufffd\050\ufffd\001\002\000\010" +
    "\027\uffed\041\uffed\050\uffed\001\002\000\006\041\072\050" +
    "\ufffd\001\002\000\022\024\041\031\026\032\037\035\024" +
    "\041\ufffd\047\023\050\ufffd\052\ufffd\001\002\000\006\041" +
    "\uffdf\050\uffdf\001\002\000\004\024\071\001\002\000\006" +
    "\041\uffe0\050\uffe0\001\002\000\012\021\063\034\uffe6\043" +
    "\uffe6\052\uffe6\001\002\000\004\052\052\001\002\000\012" +
    "\034\uffe4\041\uffe4\050\uffe4\052\uffe1\001\002\000\010\034" +
    "\uffe7\043\uffe7\052\uffe7\001\002\000\010\034\uffe8\043\uffe8" +
    "\052\uffe8\001\002\000\010\034\uffe2\043\047\052\uffe2\001" +
    "\002\000\020\024\041\031\026\032\037\034\ufffd\035\024" +
    "\047\023\052\ufffd\001\002\000\006\034\uffe3\052\uffe3\001" +
    "\002\000\006\034\uffe1\052\uffe1\001\002\000\010\012\055" +
    "\016\056\024\053\001\002\000\026\024\uffea\031\uffea\032" +
    "\uffea\034\uffea\035\uffea\041\uffea\047\uffea\050\uffea\052\uffea" +
    "\053\uffea\001\002\000\026\024\ufffd\031\ufffd\032\ufffd\034" +
    "\ufffd\035\ufffd\041\ufffd\047\ufffd\050\ufffd\052\ufffd\053\057" +
    "\001\002\000\026\024\uffeb\031\uffeb\032\uffeb\034\uffeb\035" +
    "\uffeb\041\uffeb\047\uffeb\050\uffeb\052\uffeb\053\uffeb\001\002" +
    "\000\026\024\uffec\031\uffec\032\uffec\034\uffec\035\uffec\041" +
    "\uffec\047\uffec\050\uffec\052\uffec\053\uffec\001\002\000\024" +
    "\024\uffde\031\uffde\032\uffde\034\uffde\035\uffde\041\uffde\047" +
    "\uffde\050\uffde\052\uffde\001\002\000\024\024\041\031\026" +
    "\032\037\034\ufffd\035\024\041\ufffd\047\023\050\ufffd\052" +
    "\ufffd\001\002\000\024\024\uffdd\031\uffdd\032\uffdd\034\uffdd" +
    "\035\uffdd\041\uffdd\047\uffdd\050\uffdd\052\uffdd\001\002\000" +
    "\010\034\uffe5\041\uffe5\050\uffe5\001\002\000\006\024\067" +
    "\047\064\001\002\000\006\004\ufff1\023\ufff1\001\002\000" +
    "\006\004\uffef\023\uffef\001\002\000\004\023\070\001\002" +
    "\000\010\004\ufff0\021\063\023\ufff0\001\002\000\034\004" +
    "\uffba\006\uffba\023\uffba\025\uffba\034\uffba\037\uffba\040\uffba" +
    "\043\uffba\051\uffba\052\uffba\053\uffba\054\uffba\055\uffba\001" +
    "\002\000\010\034\uffe9\043\uffe9\052\uffe9\001\002\000\010" +
    "\014\234\022\231\050\ufffd\001\002\000\004\050\075\001" +
    "\002\000\004\050\uffd0\001\002\000\014\013\ufffd\015\076" +
    "\017\103\024\102\046\104\001\002\000\004\024\216\001" +
    "\002\000\016\013\uffaf\015\uffaf\017\uffaf\024\uffaf\026\uffaf" +
    "\046\uffaf\001\002\000\004\013\uffce\001\002\000\016\013" +
    "\ufffd\015\076\017\103\024\102\026\ufffd\046\104\001\002" +
    "\000\010\021\063\033\156\055\uffb9\001\002\000\020\007" +
    "\134\021\125\024\124\031\121\033\126\035\123\047\120" +
    "\001\002\000\004\033\165\001\002\000\004\055\117\001" +
    "\002\000\016\013\uffac\015\uffac\017\uffac\024\uffac\026\uffac" +
    "\046\uffac\001\002\000\016\013\uffad\015\uffad\017\uffad\024" +
    "\uffad\026\uffad\046\uffad\001\002\000\016\013\uffae\015\uffae" +
    "\017\uffae\024\uffae\026\uffae\046\uffae\001\002\000\006\013" +
    "\uffa3\026\uffa3\001\002\000\004\053\uffb1\001\002\000\004" +
    "\055\uffb8\001\002\000\016\013\uffab\015\uffab\017\uffab\024" +
    "\uffab\026\uffab\046\uffab\001\002\000\004\053\116\001\002" +
    "\000\020\010\uffb0\013\uffb0\015\uffb0\017\uffb0\024\uffb0\026" +
    "\uffb0\046\uffb0\001\002\000\020\007\134\021\125\024\124" +
    "\031\121\033\126\035\123\047\120\001\002\000\030\004" +
    "\uffc5\006\uffc5\023\uffc5\025\uffc5\034\uffc5\037\uffc5\040\uffc5" +
    "\051\uffc5\052\uffc5\053\uffc5\054\uffc5\001\002\000\030\004" +
    "\uffc7\006\uffc7\023\uffc7\025\uffc7\034\uffc7\037\uffc7\040\uffc7" +
    "\051\uffc7\052\uffc7\053\uffc7\054\uffc7\001\002\000\004\053" +
    "\uffb7\001\002\000\030\004\uffc8\006\uffc8\023\uffc8\025\uffc8" +
    "\034\uffc8\037\uffc8\040\uffc8\051\uffc8\052\uffc8\053\uffc8\054" +
    "\uffc8\001\002\000\034\004\uffca\006\uffca\021\063\023\uffca" +
    "\025\uffca\033\156\034\uffca\037\uffca\040\uffca\051\uffca\052" +
    "\uffca\053\uffca\054\uffca\001\002\000\020\007\134\021\125" +
    "\024\124\031\121\033\126\035\123\047\120\001\002\000" +
    "\020\007\134\021\125\024\124\031\121\033\126\035\123" +
    "\047\120\001\002\000\030\004\uffbd\006\uffbd\023\uffbd\025" +
    "\uffbd\034\uffbd\037\uffbd\040\uffbd\051\uffbd\052\uffbd\053\uffbd" +
    "\054\uffbd\001\002\000\030\004\uffbf\006\uffbf\023\uffbf\025" +
    "\uffbf\034\uffbf\037\uffbf\040\uffbf\051\uffbf\052\uffbf\053\uffbf" +
    "\054\uffbf\001\002\000\016\025\143\037\144\040\141\051" +
    "\140\053\uffb5\054\142\001\002\000\030\004\uffc2\006\uffc2" +
    "\023\uffc2\025\uffc2\034\uffc2\037\uffc2\040\uffc2\051\uffc2\052" +
    "\uffc2\053\uffc2\054\uffc2\001\002\000\030\004\uffc4\006\uffc4" +
    "\023\uffc4\025\uffc4\034\uffc4\037\uffc4\040\uffc4\051\uffc4\052" +
    "\uffc4\053\uffc4\054\uffc4\001\002\000\020\007\134\021\125" +
    "\024\124\031\121\033\126\035\123\047\120\001\002\000" +
    "\030\004\uffc9\006\uffc9\023\uffc9\025\uffc9\034\uffc9\037\uffc9" +
    "\040\uffc9\051\uffc9\052\uffc9\053\uffc9\054\uffc9\001\002\000" +
    "\030\004\uffc6\006\uffc6\023\uffc6\025\uffc6\034\uffc6\037\uffc6" +
    "\040\uffc6\051\uffc6\052\uffc6\053\uffc6\054\uffc6\001\002\000" +
    "\030\004\uffbe\006\uffbe\023\uffbe\025\uffbe\034\uffbe\037\uffbe" +
    "\040\uffbe\051\uffbe\052\uffbe\053\uffbe\054\uffbe\001\002\000" +
    "\020\007\134\021\125\024\124\031\121\033\126\035\123" +
    "\047\120\001\002\000\020\007\134\021\125\024\124\031" +
    "\121\033\126\035\123\047\120\001\002\000\020\007\134" +
    "\021\125\024\124\031\121\033\126\035\123\047\120\001" +
    "\002\000\020\007\134\021\125\024\124\031\121\033\126" +
    "\035\123\047\120\001\002\000\020\007\134\021\125\024" +
    "\124\031\121\033\126\035\123\047\120\001\002\000\030" +
    "\004\uffc0\006\uffc0\023\uffc0\025\uffc0\034\uffc0\037\uffc0\040" +
    "\uffc0\051\uffc0\052\uffc0\053\uffc0\054\uffc0\001\002\000\030" +
    "\004\uffcb\006\uffcb\023\uffcb\025\uffcb\034\uffcb\037\144\040" +
    "\uffcb\051\uffcb\052\uffcb\053\uffcb\054\uffcb\001\002\000\030" +
    "\004\uffcc\006\uffcc\023\uffcc\025\uffcc\034\uffcc\037\144\040" +
    "\uffcc\051\uffcc\052\uffcc\053\uffcc\054\uffcc\001\002\000\030" +
    "\004\uffc3\006\uffc3\023\uffc3\025\uffc3\034\uffc3\037\144\040" +
    "\uffc3\051\uffc3\052\uffc3\053\uffc3\054\uffc3\001\002\000\030" +
    "\004\uffc1\006\uffc1\023\uffc1\025\uffc1\034\uffc1\037\144\040" +
    "\uffc1\051\uffc1\052\uffc1\053\uffc1\054\uffc1\001\002\000\016" +
    "\025\143\034\153\037\144\040\141\051\140\054\142\001" +
    "\002\000\030\004\uffbc\006\uffbc\023\uffbc\025\uffbc\034\uffbc" +
    "\037\uffbc\040\uffbc\051\uffbc\052\uffbc\053\uffbc\054\uffbc\001" +
    "\002\000\016\023\155\025\143\037\144\040\141\051\140" +
    "\054\142\001\002\000\030\004\uffbb\006\uffbb\023\uffbb\025" +
    "\uffbb\034\uffbb\037\uffbb\040\uffbb\051\uffbb\052\uffbb\053\uffbb" +
    "\054\uffbb\001\002\000\016\024\041\031\026\032\037\034" +
    "\ufffd\035\024\047\023\001\002\000\004\034\uffb3\001\002" +
    "\000\004\034\uffb4\001\002\000\004\034\162\001\002\000" +
    "\030\004\uffb2\006\uffb2\023\uffb2\025\uffb2\034\uffb2\037\uffb2" +
    "\040\uffb2\051\uffb2\052\uffb2\053\uffb2\054\uffb2\001\002\000" +
    "\004\053\164\001\002\000\020\010\uffb6\013\uffb6\015\uffb6" +
    "\017\uffb6\024\uffb6\026\uffb6\046\uffb6\001\002\000\024\007" +
    "\134\021\125\024\124\030\166\031\121\033\126\034\ufffd" +
    "\035\123\047\120\001\002\000\004\034\uff94\001\002\000" +
    "\016\025\143\034\uff93\037\144\040\141\051\140\054\142" +
    "\001\002\000\004\034\uff91\001\002\000\004\034\uff92\001" +
    "\002\000\004\034\173\001\002\000\004\053\174\001\002" +
    "\000\020\010\uff90\013\uff90\015\uff90\017\uff90\024\uff90\026" +
    "\uff90\046\uff90\001\002\000\016\006\176\025\143\037\144" +
    "\040\141\051\140\054\142\001\002\000\004\052\177\001" +
    "\002\000\016\013\ufffd\015\076\017\103\024\102\026\ufffd" +
    "\046\104\001\002\000\006\013\ufffd\026\202\001\002\000" +
    "\004\013\uffa0\001\002\000\004\052\204\001\002\000\004" +
    "\013\uff99\001\002\000\014\013\ufffd\015\076\017\103\024" +
    "\102\046\104\001\002\000\004\013\uff9a\001\002\000\004" +
    "\013\207\001\002\000\004\017\210\001\002\000\004\053" +
    "\211\001\002\000\016\013\uff9f\015\uff9f\017\uff9f\024\uff9f" +
    "\026\uff9f\046\uff9f\001\002\000\006\013\uffa4\026\uffa4\001" +
    "\002\000\004\013\214\001\002\000\004\044\215\001\002" +
    "\000\004\002\uffcd\001\002\000\004\036\217\001\002\000" +
    "\020\007\134\021\125\024\124\031\121\033\126\035\123" +
    "\047\120\001\002\000\016\004\221\025\143\037\144\040" +
    "\141\051\140\054\142\001\002\000\020\007\134\021\125" +
    "\024\124\031\121\033\126\035\123\047\120\001\002\000" +
    "\016\025\143\037\144\040\141\051\140\052\223\054\142" +
    "\001\002\000\014\013\ufffd\015\076\017\103\024\102\046" +
    "\104\001\002\000\004\013\uff98\001\002\000\004\013\226" +
    "\001\002\000\004\015\227\001\002\000\004\053\230\001" +
    "\002\000\016\013\uff97\015\uff97\017\uff97\024\uff97\026\uff97" +
    "\046\uff97\001\002\000\004\024\327\001\002\000\010\014" +
    "\uffd5\022\uffd5\050\uffd5\001\002\000\004\050\uffd1\001\002" +
    "\000\004\024\241\001\002\000\010\014\uffd4\022\uffd4\050" +
    "\uffd4\001\002\000\010\014\234\022\231\050\ufffd\001\002" +
    "\000\004\050\uffd2\001\002\000\004\050\uffd3\001\002\000" +
    "\004\033\242\001\002\000\020\024\041\031\026\032\037" +
    "\034\ufffd\035\024\047\023\052\ufffd\001\002\000\004\034" +
    "\uffda\001\002\000\004\034\245\001\002\000\004\052\246" +
    "\001\002\000\014\027\ufffd\041\ufffd\042\ufffd\045\015\050" +
    "\ufffd\001\002\000\012\027\ufffd\041\ufffd\042\031\050\ufffd" +
    "\001\002\000\010\027\035\041\ufffd\050\ufffd\001\002\000" +
    "\006\041\072\050\ufffd\001\002\000\004\050\253\001\002" +
    "\000\014\010\264\015\254\017\257\024\102\046\104\001" +
    "\002\000\004\024\314\001\002\000\020\010\uffaa\013\uffaa" +
    "\015\uffaa\017\uffaa\024\uffaa\026\uffaa\046\uffaa\001\002\000" +
    "\020\010\uffa8\013\uffa8\015\uffa8\017\uffa8\024\uffa8\026\uffa8" +
    "\046\uffa8\001\002\000\020\007\134\021\125\024\124\031" +
    "\121\033\126\035\123\047\120\001\002\000\020\010\uffa5" +
    "\013\uffa5\015\uffa5\017\uffa5\024\uffa5\026\uffa5\046\uffa5\001" +
    "\002\000\020\010\uffa9\013\uffa9\015\uffa9\017\uffa9\024\uffa9" +
    "\026\uffa9\046\uffa9\001\002\000\020\010\uffa7\013\uffa7\015" +
    "\uffa7\017\uffa7\024\uffa7\026\uffa7\046\uffa7\001\002\000\016" +
    "\010\264\013\ufffd\015\254\017\257\024\102\046\104\001" +
    "\002\000\020\007\134\021\125\024\124\031\121\033\126" +
    "\035\123\047\120\001\002\000\020\010\uffa6\013\uffa6\015" +
    "\uffa6\017\uffa6\024\uffa6\026\uffa6\046\uffa6\001\002\000\016" +
    "\025\143\037\144\040\141\051\140\053\uff8f\054\142\001" +
    "\002\000\004\053\270\001\002\000\020\010\uff8e\013\uff8e" +
    "\015\uff8e\017\uff8e\024\uff8e\026\uff8e\046\uff8e\001\002\000" +
    "\004\013\275\001\002\000\020\010\264\013\ufffd\015\254" +
    "\017\257\024\102\026\ufffd\046\104\001\002\000\006\013" +
    "\uffa1\026\uffa1\001\002\000\006\013\uffa2\026\uffa2\001\002" +
    "\000\004\053\276\001\002\000\010\014\uffd9\022\uffd9\050" +
    "\uffd9\001\002\000\016\006\300\025\143\037\144\040\141" +
    "\051\140\054\142\001\002\000\004\052\301\001\002\000" +
    "\020\010\264\013\ufffd\015\254\017\257\024\102\026\ufffd" +
    "\046\104\001\002\000\006\013\ufffd\026\303\001\002\000" +
    "\004\052\312\001\002\000\004\013\uff9b\001\002\000\004" +
    "\013\uff9e\001\002\000\004\013\307\001\002\000\004\017" +
    "\310\001\002\000\004\053\311\001\002\000\020\010\uff9d" +
    "\013\uff9d\015\uff9d\017\uff9d\024\uff9d\026\uff9d\046\uff9d\001" +
    "\002\000\016\010\264\013\ufffd\015\254\017\257\024\102" +
    "\046\104\001\002\000\004\013\uff9c\001\002\000\004\036" +
    "\315\001\002\000\020\007\134\021\125\024\124\031\121" +
    "\033\126\035\123\047\120\001\002\000\016\004\317\025" +
    "\143\037\144\040\141\051\140\054\142\001\002\000\020" +
    "\007\134\021\125\024\124\031\121\033\126\035\123\047" +
    "\120\001\002\000\016\025\143\037\144\040\141\051\140" +
    "\052\321\054\142\001\002\000\016\010\264\013\ufffd\015" +
    "\254\017\257\024\102\046\104\001\002\000\004\013\uff96" +
    "\001\002\000\004\013\324\001\002\000\004\015\325\001" +
    "\002\000\004\053\326\001\002\000\020\010\uff95\013\uff95" +
    "\015\uff95\017\uff95\024\uff95\026\uff95\046\uff95\001\002\000" +
    "\004\033\330\001\002\000\020\024\041\031\026\032\037" +
    "\034\ufffd\035\024\047\023\052\ufffd\001\002\000\004\034" +
    "\332\001\002\000\004\052\333\001\002\000\010\012\337" +
    "\016\336\024\335\001\002\000\004\052\uffd8\001\002\000" +
    "\004\052\uffdc\001\002\000\006\052\ufff3\053\ufff3\001\002" +
    "\000\006\052\ufff2\053\ufff2\001\002\000\004\052\uffdb\001" +
    "\002\000\004\052\342\001\002\000\014\027\ufffd\041\ufffd" +
    "\042\ufffd\045\015\050\ufffd\001\002\000\012\027\ufffd\041" +
    "\ufffd\042\031\050\ufffd\001\002\000\010\027\035\041\ufffd" +
    "\050\ufffd\001\002\000\006\041\072\050\ufffd\001\002\000" +
    "\004\050\347\001\002\000\014\010\264\015\254\017\257" +
    "\024\102\046\104\001\002\000\016\010\264\013\ufffd\015" +
    "\254\017\257\024\102\046\104\001\002\000\004\013\uffd7" +
    "\001\002\000\004\013\353\001\002\000\004\053\354\001" +
    "\002\000\010\014\uffd6\022\uffd6\050\uffd6\001\002\000\010" +
    "\027\uffee\041\uffee\050\uffee\001\002\000\004\055\360\001" +
    "\002\000\010\027\ufff4\041\ufff4\050\ufff4\001\002\000\004" +
    "\020\361\001\002\000\004\021\362\001\002\000\006\024" +
    "\067\047\064\001\002\000\004\004\364\001\002\000\006" +
    "\024\067\047\064\001\002\000\004\023\366\001\002\000" +
    "\004\005\367\001\002\000\006\012\337\016\336\001\002" +
    "\000\004\053\371\001\002\000\012\024\356\027\ufffd\041" +
    "\ufffd\050\ufffd\001\002\000\010\027\ufff5\041\ufff5\050\ufff5" +
    "\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\371\000\006\002\003\062\004\001\001\000\002\001" +
    "\001\000\006\003\005\024\006\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\066\011\001" +
    "\001\000\002\001\001\000\006\004\015\007\013\001\001" +
    "\000\006\004\032\013\031\001\001\000\006\004\020\005" +
    "\016\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\006\024\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\004\020\005\027\001\001\000\002\001" +
    "\001\000\006\004\356\010\354\001\001\000\006\004\035" +
    "\017\033\001\001\000\002\001\001\000\006\004\073\023" +
    "\072\001\001\000\016\004\042\006\044\014\037\016\041" +
    "\025\045\033\043\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\014\004\050\006\044\016\047\025\045" +
    "\033\043\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\015\053\001\001\000\002\001\001\000\006\004\060" +
    "\021\057\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\016\004\042\006\044\014\061\016\041" +
    "\025\045\033\043\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\012\065\033\064\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\004\236\020\232" +
    "\034\231\035\234\036\235\001\001\000\002\001\001\000" +
    "\002\001\001\000\030\004\110\033\112\040\111\041\104" +
    "\042\076\044\105\045\100\047\077\051\107\055\106\061" +
    "\113\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\067\212\001\001\000\030\004\110\033\112\040\111\041" +
    "\104\042\076\044\105\045\100\047\211\051\107\055\106" +
    "\061\113\001\001\000\002\001\001\000\020\026\174\027" +
    "\132\030\131\031\127\032\126\033\135\040\134\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\072\114\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\022\026\130\027\132" +
    "\030\131\031\127\032\126\033\135\040\134\060\121\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\070\162" +
    "\001\001\000\002\001\001\000\002\001\001\000\020\026" +
    "\153\027\132\030\131\031\127\032\126\033\135\040\134" +
    "\001\001\000\020\026\151\027\132\030\131\031\127\032" +
    "\126\033\135\040\134\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\020\026\136\027\132\030\131\031\127\032\126" +
    "\033\135\040\134\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\020\026\150\027\132\030\131" +
    "\031\127\032\126\033\135\040\134\001\001\000\020\026" +
    "\147\027\132\030\131\031\127\032\126\033\135\040\134" +
    "\001\001\000\020\026\146\027\132\030\131\031\127\032" +
    "\126\033\135\040\134\001\001\000\020\026\145\027\132" +
    "\030\131\031\127\032\126\033\135\040\134\001\001\000" +
    "\020\026\144\027\132\030\131\031\127\032\126\033\135" +
    "\040\134\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\016\004\050\006\044\016\157\025\045\033\043" +
    "\037\156\001\001\000\004\071\160\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\024\004\170\026\166\027\132\030" +
    "\131\031\127\032\126\033\135\040\134\043\167\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\077\171\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\030\004\110\033\112\040\111\041\104\042\076\044\105" +
    "\045\100\047\177\051\107\055\106\061\113\001\001\000" +
    "\006\004\202\053\200\001\001\000\004\073\205\001\001" +
    "\000\002\001\001\000\002\001\001\000\030\004\110\033" +
    "\112\040\111\041\104\042\076\044\105\045\100\047\204" +
    "\051\107\055\106\061\113\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\020\026\217" +
    "\027\132\030\131\031\127\032\126\033\135\040\134\001" +
    "\001\000\002\001\001\000\020\026\221\027\132\030\131" +
    "\031\127\032\126\033\135\040\134\001\001\000\002\001" +
    "\001\000\030\004\110\033\112\040\111\041\104\042\076" +
    "\044\105\045\100\047\223\051\107\055\106\061\113\001" +
    "\001\000\004\075\224\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\004\236\020\237\034\231\035" +
    "\234\036\235\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\016\004\042\006\044\014\242\016" +
    "\041\025\045\033\043\001\001\000\004\063\243\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\004\015\007" +
    "\246\001\001\000\006\004\032\013\247\001\001\000\006" +
    "\004\035\017\250\001\001\000\006\004\073\023\251\001" +
    "\001\000\002\001\001\000\026\033\112\040\111\041\104" +
    "\042\254\044\261\046\262\052\260\056\255\057\257\061" +
    "\264\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\020\026\276\027\132\030\131\031\127\032" +
    "\126\033\135\040\134\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\032\004\272\033\112\040" +
    "\111\041\104\042\254\044\261\046\271\050\270\052\260" +
    "\056\255\057\257\061\264\001\001\000\020\026\265\027" +
    "\132\030\131\031\127\032\126\033\135\040\134\001\001" +
    "\000\002\001\001\000\004\100\266\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\032\004\272" +
    "\033\112\040\111\041\104\042\254\044\261\046\271\050" +
    "\273\052\260\056\255\057\257\061\264\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\032\004\272" +
    "\033\112\040\111\041\104\042\254\044\261\046\271\050" +
    "\301\052\260\056\255\057\257\061\264\001\001\000\006" +
    "\004\303\054\304\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\074\305\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\032\004" +
    "\272\033\112\040\111\041\104\042\254\044\261\046\271" +
    "\050\312\052\260\056\255\057\257\061\264\001\001\000" +
    "\002\001\001\000\002\001\001\000\020\026\315\027\132" +
    "\030\131\031\127\032\126\033\135\040\134\001\001\000" +
    "\002\001\001\000\020\026\317\027\132\030\131\031\127" +
    "\032\126\033\135\040\134\001\001\000\002\001\001\000" +
    "\032\004\272\033\112\040\111\041\104\042\254\044\261" +
    "\046\271\050\321\052\260\056\255\057\257\061\264\001" +
    "\001\000\004\076\322\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\016\004\042\006\044\014\330\016\041\025\045" +
    "\033\043\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\011\337\022\333\001\001\000\004\064\340\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\004\015\007\342" +
    "\001\001\000\006\004\032\013\343\001\001\000\006\004" +
    "\035\017\344\001\001\000\006\004\073\023\345\001\001" +
    "\000\002\001\001\000\026\033\112\040\111\041\104\042" +
    "\254\044\261\046\347\052\260\056\255\057\257\061\264" +
    "\001\001\000\032\004\272\033\112\040\111\041\104\042" +
    "\254\044\261\046\271\050\350\052\260\056\255\057\257" +
    "\061\264\001\001\000\004\065\351\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\012\362\033\064\001\001\000\002" +
    "\001\001\000\006\012\364\033\064\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\011\367\001\001\000\002" +
    "\001\001\000\006\004\356\010\371\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();

	public void syntax_error (Symbol symbol) {
		Token token = (Token)symbol.value;
		syntaxErrorManager.syntaxError("Error sintactico", token);
	}

	public void unrecovered_syntax_error (java_cup.runtime.Symbol symbol) {
		Token token = (Token)symbol.value;
		syntaxErrorManager.syntaxFatalError("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager();
	ScopeManagerIF scopeManager = CompilerContext.getScopeManager();
	FinalCodeFactoryIF finalCodeFactory = CompilerContext.getFinalCodeFactory();

	ExecutionEnvironmentIF finalCode = CompilerContext.getExecutionEnvironment();

	// Lista para almacenar las cadenas de caracteres.
	List<QuadrupleIF> strings = new ArrayList<QuadrupleIF>();

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // sentenciaDevolver ::= FRETURN expresion NT$14 DSENTENCIAS 
            {
              SentenciaDevolver RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (SentenciaDevolver) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaDevolver",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // NT$14 ::= 
            {
              SentenciaDevolver RESULT =null;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	ScopeIF currentScope = scopeManager.getCurrentScope();
	ScopeIF parentScope = scopeManager.getParentScope();

	SymbolFunction function = (SymbolFunction)parentScope.getSymbolTable().getSymbol(currentScope.getName().toUpperCase());

	TypeIF expressionType = expression.getType();

	String expressionTypeName = expressionType.getName();
	String returnTypeName = function.getReturnType().getName();

	// Se comprueba que el tipo de la expresion a devolver coincida con el tipo de retorno de la funcion.
	if (expressionTypeName.equals(returnTypeName)) {
		function.hasReturnStatement(true);

		SentenciaDevolver returnStatement = new SentenciaDevolver(expression, expressionType);

		// Generacion del codigo intermedio para la sentencia devolver.
		LabelFactory labelFactory = new LabelFactory();
		TemporalFactory temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF expressionTemporal = expression.getTemporal();

		LabelIF returnLabel = labelFactory.create("F" + currentScope.getName());

		cb.addQuadruples(expression.getIntermediateCode());
		cb.addQuadruple("RET", returnLabel, expressionTemporal);

		returnStatement.setIntermediateCode(cb.create());

		RESULT = returnStatement;
	} else {
		semanticErrorManager.semanticFatalError("error: incompatible types: " + expressionTypeName + " cannot be converted to " + returnTypeName);
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$14",62, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir NT$13 PDERECHO DSENTENCIAS 
            {
              SentenciaEscribir RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (SentenciaEscribir) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int pescribirleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pescribirright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ParametroEscribir pescribir = (ParametroEscribir)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaEscribir",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // NT$13 ::= 
            {
              SentenciaEscribir RESULT =null;
		int pescribirleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pescribirright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ParametroEscribir pescribir = (ParametroEscribir)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	SentenciaEscribir sescribir = new SentenciaEscribir(pescribir);

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(pescribir.getIntermediateCode());

	sescribir.setIntermediateCode(cb.create());

	RESULT = sescribir;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$13",61, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // parametroEscribir ::= epsilon 
            {
              ParametroEscribir RESULT =null;
		
	ParametroEscribir pescribir = new ParametroEscribir();
	
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruple("WRITELN");

	pescribir.setIntermediateCode(cb.create());

	RESULT = pescribir;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametroEscribir",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // parametroEscribir ::= expresion 
            {
              ParametroEscribir RESULT =null;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se comprueba que la expresion sea de tipo entero.
	if (expression.getType().getName().equals("ENTERO")) {
		ParametroEscribir pescribir = new ParametroEscribir();
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para imprimir expresiones enteras.
		TemporalFactory temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF expressionTemporal = expression.getTemporal();

		cb.addQuadruples(expression.getIntermediateCode());
		cb.addQuadruple("WRITEINT", expressionTemporal);

		pescribir.setTemporal(expressionTemporal);
		pescribir.setIntermediateCode(cb.create());

		RESULT = pescribir;
	} else {
		semanticErrorManager.semanticFatalError("error: incompatible types: expression must be of type entero");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametroEscribir",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // parametroEscribir ::= STRING 
            {
              ParametroEscribir RESULT =null;
		int stringleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int stringright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token string = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ParametroEscribir pescribir = new ParametroEscribir();
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para imprimir cadenas.
	LabelFactoryIF labelFactory = new LabelFactory();
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	LabelIF stringLabel = labelFactory.create();

	TemporalIF stringTemporal = temporalFactory.create();

	Value stringValue = new Value(string.getLexema());

	cb.addQuadruple("WRITESTRING", stringTemporal, stringLabel);

	// Se almacena la cadena de caracteres para recuperar al final del programa principal.
	strings.add(new Quadruple("CADENA", new Label(string.getLexema()), stringLabel));

	pescribir.setTemporal(stringTemporal);
	pescribir.setIntermediateCode(cb.create());

	RESULT = pescribir;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametroEscribir",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentenciasFuncion NT$12 FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS 
            {
              SentenciaFor RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (SentenciaFor) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-10)).value;
		int startExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int startExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Expresion startExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int endExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int endExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Expresion endExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaforFuncion",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // NT$12 ::= 
            {
              SentenciaFor RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int startExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int startExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion startExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int endExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int endExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion endExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

	String name = id.getLexema();

	// Se comprueba que la variable indice haya sido declarada previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());

		// Se comprueba si el indice se trata de una variable.
		if (!(symbol instanceof SymbolVariable variable)) {
			semanticErrorManager.semanticFatalError("error: variable expected, but " + symbol.getClass().getName() + " found");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}
	// Se comprueba que las expresiones que delimitan el rango sean de tipo entero.
	if (!startExpression.getType().equals(scopeManager.searchType("ENTERO"))) {
		semanticErrorManager.semanticFatalError("error: the initial value of the index must be an integer");
	}
	if (!endExpression.getType().equals(scopeManager.searchType("ENTERO"))) {
		semanticErrorManager.semanticFatalError("error: the final value of the index must be an integer");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$12",60, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // sentenciafor ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentencias NT$11 FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS 
            {
              SentenciaFor RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (SentenciaFor) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-10)).value;
		int startExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int startExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Expresion startExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int endExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int endExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Expresion endExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		ListaSentencias statements = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciafor",43, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // NT$11 ::= 
            {
              SentenciaFor RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int startExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int startExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion startExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int endExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int endExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion endExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaSentencias statements = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	String name = id.getLexema();

	// Se comprueba que la variable indice haya sido declarada previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		// Se comprueba que las expresiones que delimitan el rango sean de tipo entero.
		if (startExpression.getType().equals(scopeManager.searchType("ENTERO"))) {
			if (endExpression.getType().equals(scopeManager.searchType("ENTERO"))) {
				SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());
				
				// Se obtiene el identificador y ambito de declaracion del indice si se trata de una variable.
				if (symbol instanceof SymbolVariable variable) {
					Variable indexVariable = new Variable(name.toUpperCase(), variable.getScope());
					ScopeIF currentScope = scopeManager.getCurrentScope();
					
					SentenciaFor sfor = new SentenciaFor();
					
					// Generacion del codigo intermedio para la sentencia iterativa para.
					LabelFactory labelFactory = new LabelFactory();
					TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

					TemporalIF identifierTemporal = temporalFactory.create();

					LabelIF startLabel = labelFactory.create();
					LabelIF endLabel = labelFactory.create();

					TemporalIF indexAddress = temporalFactory.create();
					TemporalIF indexPointer = temporalFactory.create();
					TemporalIF resultTemporal = temporalFactory.create();
					
					// Se inicializa la variable indice
					cb.addQuadruples(startExpression.getIntermediateCode());
					cb.addQuadruple("MVA", indexAddress, indexVariable);
					cb.addQuadruple("STP", indexAddress, startExpression.getTemporal());

					cb.addQuadruples(endExpression.getIntermediateCode());
					cb.addQuadruple("INC", endExpression.getTemporal());

					// Se inserta la etiqueta de comienzo del bucle.
					cb.addQuadruple("INL", startLabel);
					
					cb.addQuadruple("MVP", indexPointer, indexVariable);

					// Se compara el valor de la variable indice con la expresion final.
					cb.addQuadruple("LS", resultTemporal, indexPointer, endExpression.getTemporal());

					// Salto a la etiqueta de fin del bucle si no se cumple la condicion.
					cb.addQuadruple("BRF", resultTemporal, endLabel);
					// Sentencias dentro del cuerpo del bucle
					cb.addQuadruples(statements.getIntermediateCode());

					// Se incrementa en uno el valor de la variable indice.
					cb.addQuadruple("INC", indexVariable);

					cb.addQuadruple("BR", startLabel);
					cb.addQuadruple("INL", endLabel);

					sfor.setIntermediateCode(cb.create());

					RESULT = sfor;
				} else {
					semanticErrorManager.semanticFatalError("error: variable expected, but " + symbol.getClass().getName() + " found");
				}
			} else {
				semanticErrorManager.semanticFatalError("error: the final value of the index must be an integer");
			}
		} else {
			semanticErrorManager.semanticFatalError("error: the initial value of the index must be an integer");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$11",59, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // rellenoif ::= epsilon 
            {
              RellenoIf RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rellenoif",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // rellenoif ::= ALTERNATIVASI DELIMFUNC listaSentencias 
            {
              RellenoIf RESULT =null;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaSentencias statements = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RellenoIf rif = new RellenoIf();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(statements.getIntermediateCode());

	rif.setIntermediateCode(cb.create());

	RESULT = rif;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rellenoif",41, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // rellenoifFuncion ::= epsilon 
            {
              RellenoIf RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rellenoifFuncion",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // rellenoifFuncion ::= ALTERNATIVASI DELIMFUNC listaSentenciasFuncion 
            {
              RellenoIf RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rellenoifFuncion",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // sentenciaifFuncion ::= COMIENZOSI expresion STARTIF DELIMFUNC listaSentenciasFuncion rellenoifFuncion NT$10 FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS 
            {
              SentenciaIf RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (SentenciaIf) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		ListaSentencias statements = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaifFuncion",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // NT$10 ::= 
            {
              SentenciaIf RESULT =null;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListaSentencias statements = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

	String expressionTypeName = expression.getType().getName();

	// Se comprueba que el tipo de la expresion a evaluar sea logico.
	if (!expressionTypeName.equals("LOGICO")) {
		semanticErrorManager.semanticFatalError("error: incompatible types: " + expressionTypeName + " cannot be converted to LOGICO");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$10",58, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // sentenciaif ::= COMIENZOSI expresion STARTIF DELIMFUNC listaSentencias rellenoif NT$9 FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS 
            {
              SentenciaIf RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (SentenciaIf) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		ListaSentencias statements = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int rifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int rifright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		RellenoIf rif = (RellenoIf)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaif",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // NT$9 ::= 
            {
              SentenciaIf RESULT =null;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListaSentencias statements = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int rifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rifright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		RellenoIf rif = (RellenoIf)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	String expressionTypeName = expression.getType().getName();

	// Se comprueba que el tipo de la expresion a evaluar sea logico.
	if (expressionTypeName.equals("LOGICO")) {
		SentenciaIf sif = new SentenciaIf();
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para sentencias condicionales si-sino.
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);
		LabelFactoryIF labelFactory = new LabelFactory();

		TemporalIF expressionTemporal = expression.getTemporal();

		LabelIF elseLabel = labelFactory.create();
		LabelIF endIfLabel = labelFactory.create();

		cb.addQuadruples(expression.getIntermediateCode());
		cb.addQuadruple("BRF", expressionTemporal, elseLabel);
		cb.addQuadruples(statements.getIntermediateCode());
		cb.addQuadruple("BR", endIfLabel);
		cb.addQuadruple("INL", elseLabel);
		cb.addQuadruples(rif.getIntermediateCode());
		cb.addQuadruple("INL", endIfLabel);

		sif.setIntermediateCode(cb.create());

		RESULT = sif;
	} else {
		semanticErrorManager.semanticFatalError("error: incompatible types: " + expressionTypeName + " cannot be converted to LOGICO");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$9",57, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // listaSentenciasFuncion ::= epsilon 
            {
              ListaSentencias RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaSentenciasFuncion",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion 
            {
              ListaSentencias RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaSentenciasFuncion",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // listaSentencias ::= epsilon 
            {
              ListaSentencias RESULT =null;
		
	// Se inicializa la lista de sentencias.
	RESULT = new ListaSentencias();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaSentencias",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // listaSentencias ::= sentencia listaSentencias 
            {
              ListaSentencias RESULT =null;
		int statementleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int statementright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sentencia statement = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int statementsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int statementsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaSentencias statements = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ScopeIF currentScope = scopeManager.getCurrentScope();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	if (statement != null)
		cb.addQuadruples(statement.getIntermediateCode());

	cb.addQuadruples(statements.getIntermediateCode());

	statements.setIntermediateCode(cb.create());
	statements.add(statement);

	RESULT = statements;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaSentencias",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // sentenciaFuncion ::= sentenciaDevolver 
            {
              Sentencia RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // sentenciaFuncion ::= sentenciallamadafuncion 
            {
              Sentencia RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // sentenciaFuncion ::= sentenciaEscribir 
            {
              Sentencia RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentenciaFuncion ::= sentenciaforFuncion 
            {
              Sentencia RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentenciaFuncion ::= sentenciaifFuncion 
            {
              Sentencia RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentenciaFuncion ::= sentenciadeasignacion 
            {
              Sentencia RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentencia ::= sentenciallamadafuncion 
            {
              Sentencia RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentencia ::= sentenciaEscribir 
            {
              Sentencia RESULT =null;
		int sescribirleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sescribirright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaEscribir sescribir = (SentenciaEscribir)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia statement = new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(sescribir.getIntermediateCode());

	statement.setIntermediateCode(cb.create());

	RESULT = statement;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentencia ::= sentenciafor 
            {
              Sentencia RESULT =null;
		int sforleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sforright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaFor sfor = (SentenciaFor)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia statement = new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(sfor.getIntermediateCode());

	statement.setIntermediateCode(cb.create());

	RESULT = statement;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sentencia ::= sentenciaif 
            {
              Sentencia RESULT =null;
		int sifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sifright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaIf sif = (SentenciaIf)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia statement = new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(sif.getIntermediateCode());

	statement.setIntermediateCode(cb.create());

	RESULT = statement;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // sentencia ::= sentenciadeasignacion 
            {
              Sentencia RESULT =null;
		int sasignacionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sasignacionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaDeAsignacion sasignacion = (SentenciaDeAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia statement = new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(sasignacion.getIntermediateCode());

	statement.setIntermediateCode(cb.create());

	RESULT = statement;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // sentenciallamadafuncion ::= llamadafuncion NT$8 DSENTENCIAS 
            {
              SentenciaLlamadaFuncion RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (SentenciaLlamadaFuncion) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lfuncionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lfuncionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		LlamadaFuncion lfuncion = (LlamadaFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciallamadafuncion",47, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // NT$8 ::= 
            {
              SentenciaLlamadaFuncion RESULT =null;
		int lfuncionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lfuncionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LlamadaFuncion lfuncion = (LlamadaFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	// Se comprueba que la llamada a funcion se realiza en el contexto de una sentencia.
	if (scopeManager.searchSymbol(lfuncion.getName()) instanceof SymbolFunction) {
		semanticErrorManager.semanticFatalError("error: expected procedure, but function found");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",56, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc NT$7 PDERECHO 
            {
              LlamadaFuncion RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (LlamadaFuncion) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int parametersleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int parametersright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ListaParametros parameters = (ListaParametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadafuncion",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // NT$7 ::= 
            {
              LlamadaFuncion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int parametersleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int parametersright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaParametros parameters = (ListaParametros)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	String name = id.getLexema();

	// Se comprueba que el identificador haya sido declarado previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());

		// Se comprueba que el identificador haga referencia a un subprograma.
		if (symbol instanceof SymbolProcedure procedure) {
			ArrayList<SelectorValorOReferencia> actualParams = parameters.getParameters();
			ArrayList<SymbolParameter> formalParams = procedure.getParameters();

			// Se comprueba que el numero de parametros actuales coincide con el numero de parametros formales.
			if (actualParams.size() == formalParams.size()) {
				Iterator<SelectorValorOReferencia> it1 = actualParams.iterator();
				Iterator<SymbolParameter> it2 = formalParams.iterator();
				SymbolTableIF symbolTable = scopeManager.getCurrentScope().getSymbolTable();

				while (it1.hasNext() && it2.hasNext()) {
					SelectorValorOReferencia svor = it1.next();
					SymbolParameter formalParam = it2.next();

					// Se comprueba si el parametro actual es un elemento de un vector.
					if ((svor.getName() != null) && (svor.getValue() != "")) {
						SymbolIF actualParam = symbolTable.getSymbol(svor.getName());
						TypeArray actualParamType = (TypeArray)actualParam.getType();

						if (!(actualParamType.getBaseType().getName().equals(formalParam.getType().getName()))) {
							semanticErrorManager.semanticFatalError("error: incompatible types: " + actualParamType.getBaseType().getName() + " cannot be converted to " + formalParam.getType().getName());
						}
					} else {
						if (svor.getName() == null) {
							if (!(svor.getType().getName().equals(formalParam.getType().getName()))) {
								semanticErrorManager.semanticFatalError("error: incompatible types: " + svor.getType().getName() + " cannot be converted to " + formalParam.getType().getName());
							}
						} else if (svor.getValue() == "") {
							SymbolIF actualParam = symbolTable.getSymbol(svor.getName());
							if (!(actualParam.getType().getName().equals(formalParam.getType().getName()))) {
								semanticErrorManager.semanticFatalError("error: incompatible types: " + actualParam.getType().getName() + " cannot be converted to " + formalParam.getType().getName());
							}
						}
					}
				}

				RESULT = new LlamadaFuncion(name, procedure.getType(), actualParams);
			} else {
				semanticErrorManager.semanticFatalError("error: actual and formal argument lists differ in length");
			}
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",55, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // parametrofuncionoproc ::= listavariables 
            {
              ListaParametros RESULT =null;
		int variablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int variablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<SelectorValorOReferencia> variables = (ArrayList<SelectorValorOReferencia>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = new ListaParametros(variables);

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametrofuncionoproc",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // parametroasignacion ::= expresion 
            {
              ParametroAsignacion RESULT =null;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ParametroAsignacion assignParameter = new ParametroAsignacion(expression);

	// Generacion del codigo intermedio para la expresion en la parte derecha de la sentencia de asignacion.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression.getIntermediateCode());

	assignParameter.setTemporal(expression.getTemporal());
	assignParameter.setIntermediateCode(cb.create());

	RESULT = assignParameter;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametroasignacion",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentenciadeasignacion ::= parteizquierdaasignacion ASIGNACION parametroasignacion NT$6 DSENTENCIAS 
            {
              SentenciaDeAsignacion RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (SentenciaDeAsignacion) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int leftSideleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int leftSideright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		ParteIzquierdaAsignacion leftSide = (ParteIzquierdaAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int assignParameterleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int assignParameterright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ParametroAsignacion assignParameter = (ParametroAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciadeasignacion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // NT$6 ::= 
            {
              SentenciaDeAsignacion RESULT =null;
		int leftSideleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftSideright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ParteIzquierdaAsignacion leftSide = (ParteIzquierdaAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int assignParameterleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int assignParameterright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ParametroAsignacion assignParameter = (ParametroAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	// Se comprueba que el tipo en la parte izquierda coincide con el tipo en la parte derecha.
	if (leftSide.getType().getName().equals(assignParameter.getType().getName())) {
		SentenciaDeAsignacion sasignacion = new SentenciaDeAsignacion();
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la sentencia de asignacion.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftSideTemporal = leftSide.getTemporal();
		TemporalIF assignParameterTemporal = assignParameter.getTemporal();

		cb.addQuadruples(assignParameter.getIntermediateCode());
		cb.addQuadruples(leftSide.getIntermediateCode());
		cb.addQuadruple("STP", leftSideTemporal, assignParameterTemporal);

		sasignacion.setIntermediateCode(cb.create());

		RESULT = sasignacion;
	} else {
		semanticErrorManager.semanticFatalError("error: incompatible types: " + assignParameter.getType().getName() + " cannot be converted to " + leftSide.getType().getName());
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",54, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // parteizquierdaasignacion ::= miembrovector 
            {
              ParteIzquierdaAsignacion RESULT =null;
		int vectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		MiembroVector vector = (MiembroVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ParteIzquierdaAsignacion leftSide = new ParteIzquierdaAsignacion(vector.getName(), ((TypeArray)vector.getType()).getBaseType());

	// Generacion del codigo intermedio para la parte izquierda de una sentencia de asignacion.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(vector.getIntermediateCode());

	leftSide.setTemporal(vector.getTemporal());
	leftSide.setIntermediateCode(cb.create());

	RESULT = leftSide;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parteizquierdaasignacion",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // parteizquierdaasignacion ::= IDEN 
            {
              ParteIzquierdaAsignacion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String name = id.getLexema().toUpperCase();

	// Se comprueba si el identificador ha sido declarado previamente.
	if (scopeManager.containsSymbol(name)) {
		SymbolIF symbol = scopeManager.searchSymbol(name);

		// Se genera un error en caso de que el simbolo sea una constante simbolica.
		if (symbol instanceof SymbolConstant) {
			semanticErrorManager.semanticFatalError("error: cannot assign a value to constant " + id.getLexema() + " at line " + id.getLine());
		} else if (symbol.getType().getName().equals(name)) {
			semanticErrorManager.semanticFatalError("error: cannot assign an array directly.");
		}
		// Si el simbolo es una variable se obtiene la direccion de memoria en la que esta almacenada.
		else if (symbol instanceof SymbolVariable || symbol instanceof SymbolParameter) {
			TypeIF variableType = symbol.getType();
			ParteIzquierdaAsignacion leftSide = new ParteIzquierdaAsignacion(name, symbol.getType());
			ScopeIF currentScope = scopeManager.getCurrentScope();

			// Generacion del codigo intermedio para la parte izquierda de una sentencia de asignacion.
			TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

			TemporalIF identifierTemporal = temporalFactory.create();

			Variable identifierVariable = new Variable(name, symbol.getScope());

			cb.addQuadruple("MVA", identifierTemporal, identifierVariable);		// Temporal := &variable

			leftSide.setTemporal(identifierTemporal);
			leftSide.setIntermediateCode(cb.create());

			RESULT = leftSide;
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + id.getLexema() + " at line " + id.getLine());
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parteizquierdaasignacion",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // miembrovector ::= IDEN CIZQUIERDO valorango CDERECHO 
            {
              MiembroVector RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int vrangoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int vrangoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ValorRango vrango = (ValorRango)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();

	// Se comprueba que el identificador haya sido declarado previamente.
	if (symbolTable.containsSymbol(name.toUpperCase())) {
		SymbolIF identifier = symbolTable.getSymbol(name.toUpperCase());
		TypeIF identifierType = identifier.getType();

		// Se comprueba que el tipo del identificador sea tipo vector.
		if (identifierType instanceof TypeArray arrayType) {
			TypeIF rangeValueType = vrango.getType();

			// Si el valor del rango es de tipo vector se propaga el codigo intermedio asociado a el.
			if (rangeValueType instanceof TypeArray t) {
				// Se comprueba que el tipo de los elementos del valor del rango sea entero.
				if (t.getBaseType().getName().equals("ENTERO")) {
					MiembroVector vector = new MiembroVector(name.toUpperCase(), arrayType);

					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);
					cb.addQuadruples(vrango.getIntermediateCode());

					vector.setTemporal(vrango.getTemporal());
					vector.setIntermediateCode(cb.create());

					RESULT = vector;
				} else {
					semanticErrorManager.semanticFatalError("error: the index for the vector must be of type integer");
				}
			} else
			// Se comprueba si el valor del rango es de tipo entero.
			if (rangeValueType.getName().equals("ENTERO")) {
				// Si el valor del rango viene dado por una variable se obtiene su direccion de memoria.
				if (vrango.getName() != null) {
					SymbolIF variable = (SymbolVariable)scopeManager.searchSymbol(vrango.getName());
					
					MiembroVector vector = new MiembroVector(name.toUpperCase(), arrayType);

					TemporalFactory temporalFactory = new TemporalFactory(currentScope);
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

					TemporalIF effectiveAddress = temporalFactory.create();
					TemporalIF baseAddress = temporalFactory.create();
					TemporalIF offset = temporalFactory.create();
					TemporalIF newOffset = temporalFactory.create();

					Variable identifierVariable = new Variable(name.toUpperCase(), variable.getScope());
					Variable rangeValueVariable = new Variable(variable.getName(), variable.getScope());

					cb.addQuadruple("MVP", offset, rangeValueVariable);
					cb.addQuadruple("DEC", offset);
					cb.addQuadruple("MVA", baseAddress, identifierVariable);
					cb.addQuadruple("SUB", effectiveAddress, baseAddress, offset);

					vector.setTemporal(effectiveAddress);
					vector.setIntermediateCode(cb.create());

					RESULT = vector;
				} 
				// En cualquier otro caso el valor del rango sera un numero entero y se obtendra su valor.
				else {
					// Se comprueba que el valor dado se encuentre dentro del rango del vector.
					if (vrango.getValue() <= arrayType.getSize()) {
						MiembroVector vector = new MiembroVector(name.toUpperCase(), arrayType);

						// Generacion del codigo intermedio para el acceso a vectores.
						TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

						TemporalIF effectiveAddress = temporalFactory.create();
						TemporalIF baseAddress = temporalFactory.create();
						TemporalIF offset = temporalFactory.create();

						Value rangeValue = new Value(vrango.getValue());

						Variable identifierVariable = new Variable(name.toUpperCase(), identifier.getScope());

						cb.addQuadruple("MV", offset, rangeValue);
						cb.addQuadruple("MVA", baseAddress, identifierVariable);
						cb.addQuadruple("SUB", effectiveAddress, baseAddress, offset);

						vector.setTemporal(effectiveAddress);
						vector.setIntermediateCode(cb.create());

						RESULT = vector;
					} else {
						semanticErrorManager.semanticFatalError("error: index " + vrango.getValue() + " out of bounds for length " + arrayType.getSize());
					}
				}
			}
		} else {
			semanticErrorManager.semanticFatalError("error: array required, but " + identifierType.getName() + " found");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("miembrovector",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // expresionlvl5 ::= CIZQUIERDO expresion CDERECHO 
            {
              Expresion RESULT =null;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	Expresion expression5 = new Expresion(expression, expression.getType());

	// Generacion del codigo intermedio para expresiones entre corchetes.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression.getIntermediateCode());

	expression5.setTemporal(expression.getTemporal());
	expression5.setIntermediateCode(cb.create());

	RESULT = expression5;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl5",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // expresionlvl5 ::= PIZQUIERDO expresion PDERECHO 
            {
              Expresion RESULT =null;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	Expresion expression5 = new Expresion(expression, expression.getType());

	// Generacion del codigo intermedio para expresiones entre parentesis.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression.getIntermediateCode());	// CI de la expresion

	expression5.setTemporal(expression.getTemporal());
	expression5.setIntermediateCode(cb.create());

	RESULT = expression5;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl5",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // expresionlvl4 ::= expresionlvl5 
            {
              Expresion RESULT =null;
		int expression5left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expression5right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expression5 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion expression = new Expresion(expression5, expression5.getType());

	// Generacion del codigo intermedio para expresiones de nivel 4.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression5.getIntermediateCode());

	expression.setTemporal(expression5.getTemporal());
	expression.setIntermediateCode(cb.create());

	RESULT = expression;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl4",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // expresionlvl4 ::= NOLOGICO expresion 
            {
              Expresion RESULT =null;
		int expressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se recupera el tipo de las subexpresiones.
	TypeIF expressionType = expression.getType();

	// Se comprueba que el tipo de la subexpresion sea compatible con el operador 'no'.
	if (expressionType.getName().equals("LOGICO")) {
		Expresion expression4 = new Expresion(expression, expressionType);
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la expresion logica NOT.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF expressionTemporal = expression.getTemporal();
		TemporalIF notExpressionTemporal = temporalFactory.create();

		cb.addQuadruples(expression.getIntermediateCode());
		cb.addQuadruple("NOT", notExpressionTemporal, expressionTemporal);

		expression4.setTemporal(notExpressionTemporal);
		expression4.setIntermediateCode(cb.create());

		RESULT = expression4;
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand type for unary operator 'no'");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl4",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // expresionlvl3 ::= expresionlvl4 
            {
              Expresion RESULT =null;
		int expression4left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expression4right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expression4 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion expression = new Expresion(expression4, expression4.getType());

	// Generacion del codigo intermedio para expresiones de nivel 3.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression4.getIntermediateCode());

	expression.setTemporal(expression4.getTemporal());
	expression.setIntermediateCode(cb.create());

	RESULT = expression;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl3",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // expresionlvl3 ::= expresion PRODUCTO expresion 
            {
              Expresion RESULT =null;
		int leftExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion leftExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion rightExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se recupera el tipo de las subexpresiones.
	TypeIF leftExpressionType = leftExpression.getType(), rightExpressionType = rightExpression.getType();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador '*'.
	if (leftExpressionType.getName().equals("ENTERO") && leftExpressionType.getName().equals(rightExpressionType.getName())) {
		Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("ENTERO"));
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la expresion de multiplicacin.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftExpressionTemporal = leftExpression.getTemporal();
		TemporalIF rightExpressionTemporal = rightExpression.getTemporal();
		TemporalIF expressionTemporal = temporalFactory.create();

		cb.addQuadruples(leftExpression.getIntermediateCode());
		cb.addQuadruples(rightExpression.getIntermediateCode());
		cb.addQuadruple("MUL", expressionTemporal, leftExpressionTemporal, rightExpressionTemporal);

		expression.setTemporal(expressionTemporal);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand types for binary operator '*'");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl3",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // expresionlvl3 ::= expresion YLOGICA expresion 
            {
              Expresion RESULT =null;
		int leftExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion leftExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion rightExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se recupera el tipo de las subexpresiones.
	TypeIF leftExpressionType = leftExpression.getType(), rightExpressionType = rightExpression.getType();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador 'y'.
	if (leftExpressionType.getName().equals("LOGICO") && leftExpressionType.getName().equals(rightExpressionType.getName())) {
		Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("LOGICO"));
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la expresion logica AND.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftExpressionTemporal = leftExpression.getTemporal();
		TemporalIF rightExpressionTemporal = rightExpression.getTemporal();
		TemporalIF expressionTemporal = temporalFactory.create();

		cb.addQuadruples(leftExpression.getIntermediateCode());
		cb.addQuadruples(rightExpression.getIntermediateCode());
		cb.addQuadruple("AND", expressionTemporal, leftExpressionTemporal, rightExpressionTemporal);

		expression.setTemporal(expressionTemporal);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand types for binary operator 'y'");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl3",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // expresionlvl2 ::= expresionlvl3 
            {
              Expresion RESULT =null;
		int expression3left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expression3right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expression3 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion expression = new Expresion(expression3, expression3.getType());

	// Generacion del codigo intermedio para expresiones de nivel 2.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression3.getIntermediateCode());

	expression.setTemporal(expression3.getTemporal());
	expression.setIntermediateCode(cb.create());

	RESULT = expression;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl2",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // expresionlvl2 ::= expresion SUMA expresion 
            {
              Expresion RESULT =null;
		int leftExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion leftExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion rightExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se recupera el tipo de las subexpresiones.
	TypeIF leftExpressionType = leftExpression.getType();
	TypeIF rightExpressionType = rightExpression.getType();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador '+'.
	if (leftExpressionType.getName().equals("ENTERO") && leftExpressionType.getName().equals(rightExpressionType.getName())) {
		Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("ENTERO"));
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la expresion de suma.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftExpressionTemporal = leftExpression.getTemporal();
		TemporalIF rightExpressionTemporal = rightExpression.getTemporal();
		TemporalIF expressionTemporal = temporalFactory.create();

		cb.addQuadruples(leftExpression.getIntermediateCode());
		cb.addQuadruples(rightExpression.getIntermediateCode());
		cb.addQuadruple("ADD", expressionTemporal, leftExpressionTemporal, rightExpressionTemporal);

		expression.setTemporal(expressionTemporal);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand types for binary operator '+'");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl2",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // expresion ::= expresionlvl2 
            {
              Expresion RESULT =null;
		int expression2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expression2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expression2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion expression = new Expresion(expression2, expression2.getType());

	// Generacion del codigo intermedio para expresiones de nivel 1.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression2.getIntermediateCode());

	expression.setTemporal(expression2.getTemporal());
	expression.setIntermediateCode(cb.create());

	RESULT = expression;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // expresion ::= NUM 
            {
              Expresion RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion expression = new Expresion(scopeManager.searchType("ENTERO"));
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para un valor entero.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF expressionTemporal = temporalFactory.create();

	Value integerValue = new Value(Integer.parseInt(num.getLexema()));

	cb.addQuadruple("MV", expressionTemporal, integerValue);

	expression.setTemporal(expressionTemporal);
	expression.setIntermediateCode(cb.create());

	RESULT = expression;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // expresion ::= miembrovector 
            {
              Expresion RESULT =null;
		int mvectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mvectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		MiembroVector mvector = (MiembroVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion expression = new Expresion(mvector.getName(), ((TypeArray)mvector.getType()).getBaseType());
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para la expresion de acceso a vector.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF expressionTemporal = temporalFactory.create();

	cb.addQuadruples(mvector.getIntermediateCode());
	cb.addQuadruple("MVP", expressionTemporal, mvector.getTemporal());

	expression.setTemporal(expressionTemporal);
	expression.setIntermediateCode(cb.create());

	RESULT = expression;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // expresion ::= FALSO 
            {
              Expresion RESULT =null;
		int falsoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int falsoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token falso = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion expression = new Expresion(scopeManager.searchType("LOGICO"));
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para el valor logico falso.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF expressionTemporal = temporalFactory.create();

	cb.addQuadruple("MV", expressionTemporal, new Value(0));

	expression.setTemporal(expressionTemporal);
	expression.setIntermediateCode(cb.create());

	RESULT = expression;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // expresion ::= CIERTO 
            {
              Expresion RESULT =null;
		int ciertoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ciertoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token cierto = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion expression = new Expresion(scopeManager.searchType("LOGICO"));
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para el valor logico cierto.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF expressionTemporal = temporalFactory.create();

	cb.addQuadruple("MV", expressionTemporal, new Value(1));

	expression.setTemporal(expressionTemporal);
	expression.setIntermediateCode(cb.create());

	RESULT = expression;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // expresion ::= llamadafuncion 
            {
              Expresion RESULT =null;
		int lfuncionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lfuncionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LlamadaFuncion lfuncion = (LlamadaFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF type = scopeManager.searchType(lfuncion.getName().toUpperCase());

	// Se comprueba que la invocacion de la funcion se realiza en el contexto de una expresion.
	if (type instanceof TypeFunction functionType) {
		Expresion expression = new Expresion(functionType.getReturnType());
		ScopeIF currentScope = scopeManager.getCurrentScope();

		TemporalFactory temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF temp = temporalFactory.create();

		cb.addQuadruple("MV", temp, new Value(0));

		expression.setTemporal(temp);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: expected function, but procedure found");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // expresion ::= IDEN 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String name = id.getLexema();

	// Se comprueba que el identificador haya sido declarado previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());

		Expresion expression = new Expresion(name, symbol.getType());
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para expresiones con identificadores.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF identifierTemporal = temporalFactory.create();

		// Se obtiene el valor del simbolo cuando se trata de una constante simbolica.
		if (symbol instanceof SymbolConstantInteger constant) {
			Value constantValue = new Value(constant.getValue());
			cb.addQuadruple("MV", identifierTemporal, constantValue);
		} else if (symbol instanceof SymbolConstantBoolean constant) {
			Value constantValue = new Value(constant.getValue());
			cb.addQuadruple("MV", identifierTemporal, constantValue);
		}
		// en cualquier otro caso se obtiene su identificador y su ambito de definicion.
		else if ((symbol instanceof SymbolVariable) || (symbol instanceof SymbolParameter)) {
			Variable variable = new Variable(name.toUpperCase(), symbol.getScope());
			cb.addQuadruple("MVP", identifierTemporal, variable);
		} else {
			semanticErrorManager.semanticFatalError("error: constant or variable expected, but " + symbol.getClass().getName() + " found");
		}

		expression.setTemporal(identifierTemporal);
		expression.setIntermediateCode(cb.create());
		
		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // expresion ::= expresion IGUALDAD expresion 
            {
              Expresion RESULT =null;
		int leftExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion leftExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion rightExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se recupera el nombre del tipo de las subexpresiones.
	String leftExpressionType = leftExpression.getType().getName();
	String rightExpressionType = rightExpression.getType().getName();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador '=='.
	if (leftExpressionType.equals(rightExpressionType)) {
		Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("LOGICO"));
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para expresiones de igualdad.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftExpressionTemp = leftExpression.getTemporal();
		TemporalIF rightExpressionTemp = rightExpression.getTemporal();
		TemporalIF expressionTemp = temporalFactory.create();

		cb.addQuadruples(leftExpression.getIntermediateCode());
		cb.addQuadruples(rightExpression.getIntermediateCode());
		cb.addQuadruple("EQ", expressionTemp, leftExpressionTemp, rightExpressionTemp);

		expression.setTemporal(expressionTemp);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: incomparable types: " + leftExpressionType + " and " + rightExpressionType);
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // expresion ::= expresion MENORQUE expresion 
            {
              Expresion RESULT =null;
		int leftExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion leftExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExpressionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExpressionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion rightExpression = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String leftExpressionTypeName = leftExpression.getType().getName();
	String rightExpressionTypeName = rightExpression.getType().getName();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador '<' y entre si.
	if (leftExpressionTypeName.equals("ENTERO")) {
		if (leftExpressionTypeName.equals(rightExpressionTypeName)) {
			Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("LOGICO"));
			ScopeIF currentScope = scopeManager.getCurrentScope();

			// Generacion del codigo intermedio para la expresion menor que.
			TemporalFactory temporalFactory = new TemporalFactory(currentScope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

			TemporalIF leftExpressionTemporal = leftExpression.getTemporal();
			TemporalIF rightExpressionTemporal = rightExpression.getTemporal();
			TemporalIF resultTemporal = temporalFactory.create();

			cb.addQuadruples(leftExpression.getIntermediateCode());
			cb.addQuadruples(rightExpression.getIntermediateCode());
			cb.addQuadruple("LS", resultTemporal, leftExpressionTemporal, rightExpressionTemporal);

			expression.setTemporal(resultTemporal);
			expression.setIntermediateCode(cb.create());

			RESULT = expression;
		} else {
			semanticErrorManager.semanticFatalError("error: incomparable types: " + leftExpressionTypeName + " and " + rightExpressionTypeName);
		}
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand types for binary operator '<'");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // defprincipal ::= COMIENZOPROGRAMA IDEN NT$4 DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias NT$5 FINBLOQUESENTENCIAS FINPROGRAMA 
            {
              DefPrincipal RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (DefPrincipal) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-11)).value;
		int lsentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int lsentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ListaSentencias lsentencias = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defprincipal",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-12)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // NT$5 ::= 
            {
              DefPrincipal RESULT =(DefPrincipal) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int lsentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lsentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaSentencias lsentencias = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	DefPrincipal dprincipal = new DefPrincipal();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(lsentencias.getIntermediateCode());
	cb.addQuadruple("HALT");
	cb.addQuadruples(strings);

	dprincipal.setIntermediateCode(cb.create());

	RESULT = dprincipal;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",53, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // NT$4 ::= 
            {
              DefPrincipal RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	String name = id.getLexema();

	// Creacion del ambito global con el nombre del programa principal.
	scopeManager.openScope(name.toUpperCase());

	ScopeIF currentScope = scopeManager.getCurrentScope();
	TypeTableIF typeTable = currentScope.getTypeTable();

	// Se introducen los tipos primitivos del lenguaje en la tabla de tipos del ambito global.
	typeTable.addType("ENTERO", new TypeSimple(currentScope, "ENTERO"));
	typeTable.addType("LOGICO", new TypeSimple(currentScope, "LOGICO"));

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",52, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // seccionsubprograma ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionsubprograma",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // seccionsubprograma ::= COMIENZOSUBPROGRAMAS defsubprograma 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionsubprograma",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // defsubprograma ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defsubprograma",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // defsubprograma ::= selectorpof defsubprograma 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defsubprograma",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // selectorpof ::= funcion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorpof",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // selectorpof ::= procedimiento 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorpof",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // funcion ::= DECLAREFUNCION IDEN PIZQUIERDO defvariables PDERECHO DELIMFUNC tiporetornofuncion NT$2 DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion NT$3 FINBLOQUESENTENCIAS DSENTENCIAS 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-17)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-17)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-17)).value;
		int dvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-15)).left;
		int dvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-15)).right;
		DefVariables dvariables = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-15)).value;
		int tretornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-12)).left;
		int tretornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-12)).right;
		TypeSimple tretorno = (TypeSimple)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-12)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcion",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-18)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$3 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-14)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-14)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-14)).value;
		int dvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-12)).left;
		int dvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-12)).right;
		DefVariables dvariables = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-12)).value;
		int tretornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).left;
		int tretornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).right;
		TypeSimple tretorno = (TypeSimple)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-9)).value;

	SymbolFunction function = (SymbolFunction)scopeManager.searchSymbol(scopeManager.getCurrentScope().getName());

	// Se comprueba que al menos existe una sentencia devolver en la funcion.
	if (function.hasReturnStatement()) {
		scopeManager.closeScope();
	} else {
		semanticErrorManager.semanticFatalError("error: missing devolver statement in function " + function.getName());
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",51, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$2 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int dvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int dvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		DefVariables dvariables = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tretornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tretornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		TypeSimple tretorno = (TypeSimple)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();
	TypeTableIF typeTable = currentScope.getTypeTable();

	// Se comprueba que la funcion no haya sido declarada anteriormente.
	if ((symbolTable.containsSymbol(name.toUpperCase())) || (typeTable.containsType(name.toUpperCase()))) {
		semanticErrorManager.semanticFatalError("error: " + name + " is already defined");
	} else {
		TypeFunction type = new TypeFunction(currentScope, name.toUpperCase(), tretorno);
		SymbolFunction function = new SymbolFunction(currentScope, name.toUpperCase(), type, tretorno);

		// Se inserta una entrada en las tablas de simbolos y tipos con informacion sobre la funcion.
		symbolTable.addSymbol(function);
		typeTable.addType(type.getName().toUpperCase(), type);

		// Creacion del ambito asociado a la funcion.
		scopeManager.openScope(name.toUpperCase());
		ScopeIF functionScope = scopeManager.getCurrentScope();

		// Se inserta una entrada en la tabla de simbolos con informacion de cada parametro en la lista de parametros de la funcion.
		SymbolTableIF functionSymbolTable = functionScope.getSymbolTable();
		ArrayList<SelectorValorOReferencia> parameterList = dvariables.getVariables();

		for (SelectorValorOReferencia symbol : parameterList) {
			if (functionSymbolTable.containsSymbol(symbol.getName().toUpperCase())) {
				semanticErrorManager.semanticFatalError("error: variable " + symbol.getName() + " is already defined");
			} else {
				SymbolParameter parameter = new SymbolParameter(functionScope, symbol.getName().toUpperCase(), symbol.getType());
				type.addParameter(parameter);
				function.addParameter(parameter);
				functionSymbolTable.addSymbol(parameter);
			}
		}
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // procedimiento ::= COMIENZOPROCEDIMIENTO IDEN PIZQUIERDO defvariables NT$1 PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-11)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-14)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-14)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-14)).value;
		int dvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-12)).left;
		int dvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-12)).right;
		DefVariables dvariables = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-12)).value;
		
	// Se cierra el ambito del procedimiento.
	scopeManager.closeScope();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedimiento",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-15)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // NT$1 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int dvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DefVariables dvariables = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();

	// Se comprueba que el procedimiento no haya sido declarado anteriormente.
	if (symbolTable.containsSymbol(name.toUpperCase()) || scopeManager.containsType(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: " + name + " is already defined");
	} else {
		TypeProcedure type = new TypeProcedure(currentScope, name.toUpperCase());
		SymbolProcedure procedure = new SymbolProcedure(currentScope, name.toUpperCase(), type);

		TypeTableIF typeTable = currentScope.getTypeTable();

		// Se inserta una entrada en las tablas de simbolos y tipos con informacion sobre el procedimiento.
		symbolTable.addSymbol(procedure);
		typeTable.addType(name.toUpperCase(), type);

		// Se crea el ambito asociado al procedimiento.
		scopeManager.openScope(name.toUpperCase());
		ScopeIF procedureScope = scopeManager.getCurrentScope();

		SymbolTableIF procedureSymbolTable = procedureScope.getSymbolTable();
		ArrayList<SelectorValorOReferencia> parameterList = dvariables.getVariables();

		// Se inserta una entrada en la tabla de simbolos con informacion de cada parmetro.
		for (SelectorValorOReferencia symbol : parameterList) {
			if (procedureSymbolTable.containsSymbol(symbol.getName().toUpperCase())) {
				semanticErrorManager.semanticFatalError("error: variable " + symbol.getName() + " is already defined");
			} else {
				SymbolParameter parameter = new SymbolParameter(procedureScope, symbol.getName().toUpperCase(), symbol.getType());
				type.addParameter(parameter);
				procedure.addParameter(parameter);
				procedureSymbolTable.addSymbol(parameter);
			}
		}
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // tiporetornofuncion ::= tipovector 
            {
              TypeSimple RESULT =null;
		int tvectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tvectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		TypeSimple tvector = (TypeSimple)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = tvector;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tiporetornofuncion",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // tiporetornofuncion ::= IDEN 
            {
              TypeSimple RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Solo se permite que las funciones devuelvan un tipo basico.
	semanticErrorManager.semanticFatalError("error: integer or boolean required, but " + id.getLexema() + " found at line " + id.getLine());

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tiporetornofuncion",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // puntoycomaopcional ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("puntoycomaopcional",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // puntoycomaopcional ::= DSENTENCIAS 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("puntoycomaopcional",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // seccionvariables ::= epsilon 
            {
              ArrayList<SymbolVariable> RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionvariables",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // seccionvariables ::= DECLVARIABLES defvariables 
            {
              ArrayList<SymbolVariable> RESULT =null;
		int dvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DefVariables dvariables = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();
	ArrayList<SelectorValorOReferencia> variableList = dvariables.getVariables();

	for (SelectorValorOReferencia symbol : variableList) {
		String name = symbol.getName().toUpperCase();

		if ((symbolTable.containsSymbol(name)) | (scopeManager.containsType(name))) {
			semanticErrorManager.semanticFatalError("error: variable " + symbol.getName() + " is already defined in " + currentScope.getName());
		} else {
			symbolTable.addSymbol(new SymbolVariable(currentScope, name, symbol.getType()));
		}
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionvariables",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // listavariables ::= epsilon 
            {
              ArrayList<SelectorValorOReferencia> RESULT =null;
		
	// Se crea una lista vacia para las variables declaradas.
	RESULT = new ArrayList<SelectorValorOReferencia>();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listavariables",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // listavariables ::= selectorvalororeferencia 
            {
              ArrayList<SelectorValorOReferencia> RESULT =null;
		int svorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int svorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SelectorValorOReferencia svor = (SelectorValorOReferencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se crea una lista de variables y se aade una variable.
	ArrayList<SelectorValorOReferencia> variableList = new ArrayList<>();
	variableList.add(svor);
	RESULT = variableList;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listavariables",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // listavariables ::= selectorvalororeferencia DIDENTIFICADORES listavariables 
            {
              ArrayList<SelectorValorOReferencia> RESULT =null;
		int svorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int svorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		SelectorValorOReferencia svor = (SelectorValorOReferencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int lvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<SelectorValorOReferencia> lvariables = (ArrayList<SelectorValorOReferencia>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se aade una nueva variable a la lista de variables.
	lvariables.add(0, svor);
	RESULT = lvariables;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listavariables",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // defvariables ::= epsilon 
            {
              DefVariables RESULT =null;
		
	// Se crea una lista vacia para las variables declaradas.
	RESULT = new DefVariables();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defvariables",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // defvariables ::= listavariables DELIMFUNC tipovariable puntoycomaopcional defvariables 
            {
              DefVariables RESULT =null;
		int lvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int lvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		ArrayList<SelectorValorOReferencia> lvariables = (ArrayList<SelectorValorOReferencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tvariableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tvariableright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		TypeIF tvariable = (TypeIF)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int dvariablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dvariablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DefVariables dvariables = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Se establece el tipo de cada simbolo declarado.
	for (SelectorValorOReferencia symbol : lvariables) {
		symbol.setType(tvariable);
	}

	// Se aade la lista de variables al resto de variables declaradas.
	dvariables.addVariables(lvariables);

	RESULT = dvariables;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defvariables",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // selectorvalororeferencia ::= IDEN 
            {
              SelectorValorOReferencia RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = new SelectorValorOReferencia(id.getLexema().toUpperCase());

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorvalororeferencia",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // selectorvalororeferencia ::= miembrovector 
            {
              SelectorValorOReferencia RESULT =null;
		int mvectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mvectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		MiembroVector mvector = (MiembroVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	SelectorValorOReferencia svor = new SelectorValorOReferencia(mvector);

	// Generacion del codigo intermedio.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

	cb.addQuadruples(mvector.getIntermediateCode());

	svor.setTemporal(mvector.getTemporal());
	svor.setIntermediateCode(cb.create());

	RESULT = svor;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorvalororeferencia",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // selectorvalororeferencia ::= valorconstante 
            {
              SelectorValorOReferencia RESULT =null;
		int constanteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int constanteright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ValorConstante constante = (ValorConstante)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF type = scopeManager.searchType(constante.getType());

	SelectorValorOReferencia svor = new SelectorValorOReferencia(constante, type);
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF temp0 = temporalFactory.create();

	// Se obtiene el valor de la constante.
	Value constantValue = new Value(constante.getValue());

	cb.addQuadruple("MV", temp0, constantValue);
	cb.addQuadruple("PARAM", temp0);

	svor.setTemporal(temp0);
	svor.setIntermediateCode(cb.create());

	RESULT = svor;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorvalororeferencia",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // selectorvalororeferencia ::= PARAMETROVALOR IDEN 
            {
              SelectorValorOReferencia RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = new SelectorValorOReferencia(id.getLexema().toUpperCase());

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorvalororeferencia",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // tipovariable ::= IDEN 
            {
              TypeIF RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String name = id.getLexema();

	// Se comprueba que el tipo haya sido declarado previamente en cualquiera de los ambitos abiertos.
	if (scopeManager.containsType(name.toUpperCase())) {
		TypeIF type = scopeManager.searchType(name.toUpperCase());

		// Se comprueba que el tipo sea un tipo vector.
		if (type instanceof TypeArray arrayType) {
			RESULT = arrayType;
		} else {
			semanticErrorManager.semanticFatalError("error: array type required, but " + type.getName() + " found");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find type " + name);
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovariable",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // tipovariable ::= ENTERO 
            {
              TypeIF RESULT =null;
		
	RESULT = (TypeSimple)scopeManager.searchType("ENTERO");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovariable",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // tipovariable ::= BOOLEANO 
            {
              TypeIF RESULT =null;
		
	RESULT = (TypeSimple)scopeManager.searchType("LOGICO");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovariable",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // secciontipos ::= epsilon 
            {
              ArrayList<TypeArray> RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("secciontipos",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // secciontipos ::= COMIENZODECLTIPOS deftipos 
            {
              ArrayList<TypeArray> RESULT =null;
		int dtiposleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dtiposright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<TypeArray> dtipos = (ArrayList<TypeArray>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = dtipos;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("secciontipos",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // valorango ::= miembrovector 
            {
              ValorRango RESULT =null;
		int mvectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mvectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		MiembroVector mvector = (MiembroVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ValorRango vrango = new ValorRango();
	vrango.setType(mvector.getType());

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(mvector.getIntermediateCode());

	vrango.setTemporal(mvector.getTemporal());
	vrango.setIntermediateCode(cb.create());

	RESULT = vrango;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorango",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // valorango ::= IDEN 
            {
              ValorRango RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String name = id.getLexema();

	// Se comprueba si el identificador ha sido declarado previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());

		// Se comprueba si el identificador hace referencia a una constante simbolica entera.
		if (symbol instanceof SymbolConstantInteger constant) {
			RESULT = new ValorRango(constant.getValue(), scopeManager.searchType("ENTERO"));
		} else
		if (symbol instanceof SymbolVariable variable && variable.getType().getName().equals("ENTERO")) {
			RESULT = new ValorRango(variable.getName(), scopeManager.searchType("ENTERO"));
		} else {
			semanticErrorManager.semanticFatalError("error: expected constant or variable of type integer");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorango",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // valorango ::= NUM 
            {
              ValorRango RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	int integerLiteral = Integer.parseInt(num.getLexema()) - 1;

	ValorRango vrango = new ValorRango(integerLiteral);
	vrango.setType(scopeManager.searchType("ENTERO"));

	RESULT = vrango;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorango",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // tipovector ::= ENTERO 
            {
              TypeSimple RESULT =null;
		
	// Se obtiene el tipo primitivo entero.
	RESULT = (TypeSimple)scopeManager.searchType("ENTERO");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovector",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // tipovector ::= BOOLEANO 
            {
              TypeSimple RESULT =null;
		
	// Se obtiene el tipo primitivo booleano.
	RESULT = (TypeSimple)scopeManager.searchType("LOGICO");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovector",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // deftipos ::= epsilon 
            {
              ArrayList<TypeArray> RESULT =null;
		
	// Se crea una lista vacia para los tipos declarados.
	RESULT = new ArrayList<TypeArray>();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("deftipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // deftipos ::= IDEN ASIGNACION DECLVECTOR CIZQUIERDO valorango RANGO valorango CDERECHO ASIGNACIONVECTOR tipovector DSENTENCIAS deftipos 
            {
              ArrayList<TypeArray> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-11)).value;
		int vrango1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int vrango1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		ValorRango vrango1 = (ValorRango)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int vrango2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int vrango2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		ValorRango vrango2 = (ValorRango)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int tvectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tvectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		TypeSimple tvector = (TypeSimple)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int dtiposleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dtiposright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<TypeArray> dtipos = (ArrayList<TypeArray>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();

	if (symbolTable.containsSymbol(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: symbol " + name + " is already defined in " + currentScope.getName());
	}

	if (scopeManager.containsType(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: type " + name + " is already defined");
	}

	// Se comprueba que los valores de rango no vengan dados por variables.
	if (vrango1.getName() != null || vrango2.getName() != null) {
		semanticErrorManager.semanticFatalError("error: expected integer constant");
	}

	int firstIndex = vrango1.getValue();
	int lastIndex = vrango2.getValue();

	// Se comprueba que el indice inferior no sea mayor que el indice superior.
	if (lastIndex < firstIndex) {
		semanticErrorManager.semanticFatalError("error: last index must be greater than or equals to first index");
	}
	
	TypeTableIF typeTable = currentScope.getTypeTable();
	TypeArray arrayType = new TypeArray(currentScope, name.toUpperCase(), firstIndex, lastIndex, tvector);
	
	// Se aade informacion sobre el nuevo tipo y se inserta en la lista de tipos declarados.
	typeTable.addType(arrayType);
	dtipos.add(0, arrayType);

	RESULT = dtipos;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("deftipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // seccionconstantes ::= epsilon 
            {
              ArrayList<SymbolConstant> RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionconstantes",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // seccionconstantes ::= BCONSTANTES defconstantes 
            {
              ArrayList<SymbolConstant> RESULT =null;
		int dconstantesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dconstantesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<SymbolConstant> dconstantes = (ArrayList<SymbolConstant>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = dconstantes;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionconstantes",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // valorconstante ::= NUM 
            {
              ValorConstante RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = new ValorConstante("ENTERO", num.getLexema());

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorconstante",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // valorconstante ::= CIERTO 
            {
              ValorConstante RESULT =null;
		int ciertoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ciertoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token cierto = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = new ValorConstante("LOGICO", cierto.getLexema());

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorconstante",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // valorconstante ::= FALSO 
            {
              ValorConstante RESULT =null;
		int falsoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int falsoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token falso = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = new ValorConstante("LOGICO", falso.getLexema());

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorconstante",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // defconstantes ::= epsilon 
            {
              ArrayList<SymbolConstant> RESULT =null;
		
	// Se inicializa la lista de constantes declaradas.
	RESULT = new ArrayList<SymbolConstant>();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defconstantes",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // defconstantes ::= IDEN ASIGNACION valorconstante DSENTENCIAS defconstantes 
            {
              ArrayList<SymbolConstant> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int vconstanteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int vconstanteright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ValorConstante vconstante = (ValorConstante)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int dconstantesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dconstantesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayList<SymbolConstant> dconstantes = (ArrayList<SymbolConstant>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();

	// Se comprueba si la constante simblica ya ha sido declarada.
	if (symbolTable.containsSymbol(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: constant " + name + " is already defined in " + currentScope.getName());
	}
	// Se comprueba si el identificador hace referencia a un tipo declarado.
	else if (scopeManager.containsType(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: expected identifier, but " + name + " found");
	} else {
		TypeIF type = scopeManager.searchType(vconstante.getType());
		SymbolConstant constant = null;

		// Se determina el tipo de la constante simblica.
		if (type.getName().equals("ENTERO")) {
			constant = new SymbolConstantInteger(currentScope, name.toUpperCase(), type, Integer.parseInt(vconstante.getValue()));
		} else {
			constant = new SymbolConstantBoolean(currentScope, name.toUpperCase(), type, vconstante.getValue());
		}

		// Se aade informacion sobre la nueva constante simbolica y se inserta en la lista de constantes declaradas.
		symbolTable.addSymbol(constant);
		dconstantes.add(0, constant);

		RESULT = dconstantes;
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defconstantes",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // epsilon ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("epsilon",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // axiom ::= defprincipal 
            {
              Axiom RESULT =null;
		int dprincipalleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dprincipalright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DefPrincipal dprincipal = (DefPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	AxiomImpl ax = new AxiomImpl();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());	
	cb.addQuadruples(dprincipal.getIntermediateCode());
	
	ax.setIntermediateCode(cb.create());

	RESULT = ax;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	List<ScopeIF> scopes = scopeManager.getAllScopes();
	for (ScopeIF scope : scopes) {
		int staticAddress = finalCode.getMemorySize();

		List<SymbolIF> symbols = scope.getSymbolTable().getSymbols();
		for (SymbolIF symbol : symbols) {
			if (symbol instanceof SymbolVariable variable) {
				variable.setAddress(staticAddress);
				staticAddress -= variable.getType().getSize();
			}
		}

		List<TemporalIF> temporals = scope.getTemporalTable().getTemporals();
		for (TemporalIF temporal : temporals) {
			if (temporal instanceof Temporal t) {
				t.setAddress(staticAddress);
				staticAddress -= t.getSize();
			}
		}
	}

	for (ScopeIF scope : scopes) {
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		if (scope.getLevel() == 0) {
			List<SymbolIF> symbols = scope.getSymbolTable().getSymbols();
			for (SymbolIF symbol : symbols) {
				if (symbol instanceof SymbolVariable variable) {
					if (variable.getType().getName().equals("ENTERO") || variable.getType().getName().equals("LOGICO")) {
						Variable var = new Variable(variable.getName(), variable.getScope());
						cb.addQuadruple("VARGLOBAL", var, 0);
					} else {
						for (int i = 0; i < variable.getType().getSize(); i++) {
							Variable var = new Variable(variable.getName(), variable.getScope());
							int address = variable.getAddress() - i;
							cb.addQuadruple("VARGLOBALVECTOR", var, address, 0);
						}
					}
				}
			}
		}
		cb.addQuadruples(ax.getIntermediateCode());
		ax.setIntermediateCode(cb.create());
	}

	// No modificar esta estructura, aunque se pueden aadir ms acciones semnticas
  		
  	List intermediateCode = ax.getIntermediateCode();
  	finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
	finalCodeFactory.create(intermediateCode);

  	// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  	// en las llamadas a cupTest si el compilador no est completo. Esto es debido a que 
  	// an no se tendr implementada la generacin de codigo intermedio ni final.
  	// Para la entrega final debern descomentarse y usarse.
  		
  	syntaxErrorManager.syntaxInfo("Parsing process ended.");  	

              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;

	syntaxErrorManager.syntaxInfo("Starting parsing...");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",48, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}


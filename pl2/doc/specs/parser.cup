package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del codigo de usuario

action code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager();
	ScopeManagerIF scopeManager = CompilerContext.getScopeManager();
	FinalCodeFactoryIF finalCodeFactory = CompilerContext.getFinalCodeFactory();

	ExecutionEnvironmentIF finalCode = CompilerContext.getExecutionEnvironment();

	// Lista para almacenar las cadenas de caracteres.
	List<QuadrupleIF> strings = new ArrayList<QuadrupleIF>();
:}

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();

	public void syntax_error (Symbol symbol) {
		Token token = (Token)symbol.value;
		syntaxErrorManager.syntaxError("Error sintactico", token);
	}

	public void unrecovered_syntax_error (java_cup.runtime.Symbol symbol) {
		Token token = (Token)symbol.value;
		syntaxErrorManager.syntaxFatalError("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;

// Declaración de no terminales

non terminal program;
non terminal Axiom axiom;
non terminal epsilon;
non terminal ArrayList<SymbolConstant> defconstantes;
non terminal ValorConstante valorconstante;
non terminal ArrayList<SymbolConstant> seccionconstantes;
non terminal ArrayList<TypeArray> deftipos;
non terminal TypeSimple tipovector;
non terminal ValorRango valorango;
non terminal ArrayList<TypeArray> secciontipos;
non terminal DefVariables defvariables;
non terminal TypeIF tipovariable;
non terminal ArrayList<SelectorValorOReferencia> listavariables;
non terminal ArrayList<SymbolVariable> seccionvariables;
non terminal defsubprograma;
non terminal puntoycomaopcional;
non terminal TypeSimple tiporetornofuncion;
non terminal seccionsubprograma;
non terminal DefPrincipal defprincipal;
non terminal SelectorValorOReferencia selectorvalororeferencia;
non terminal Expresion expresion;
non terminal Expresion expresionlvl2;
non terminal Expresion expresionlvl3;
non terminal Expresion expresionlvl4;
non terminal Expresion expresionlvl5;
non terminal MiembroVector miembrovector;
non terminal procedimiento;
non terminal funcion;
non terminal selectorpof;
non terminal ListaParametros parametrofuncionoproc;
non terminal LlamadaFuncion llamadafuncion ; 
non terminal ParteIzquierdaAsignacion parteizquierdaasignacion;  
non terminal SentenciaDeAsignacion sentenciadeasignacion;
non terminal ParametroEscribir parametroEscribir ;
non terminal SentenciaEscribir sentenciaEscribir ;
non terminal Sentencia sentencia;
non terminal Sentencia sentenciaFuncion;
non terminal ListaSentencias listaSentencias;
non terminal ListaSentencias listaSentenciasFuncion;
non terminal SentenciaIf sentenciaif;
non terminal SentenciaIf sentenciaifFuncion;
non terminal RellenoIf rellenoif;
non terminal RellenoIf rellenoifFuncion;
non terminal SentenciaFor sentenciafor;
non terminal SentenciaFor sentenciaforFuncion;
non terminal SentenciaDevolver sentenciaDevolver;
non terminal ParametroAsignacion parametroasignacion;
non terminal SentenciaLlamadaFuncion sentenciallamadafuncion;

// Declaración de relaciones de precedencia

precedence left PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA;
precedence left PRODUCTO;
precedence right NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= {:
	syntaxErrorManager.syntaxInfo("Starting parsing...");
:} axiom:ax {:
	List<ScopeIF> scopes = scopeManager.getAllScopes();
	for (ScopeIF scope : scopes) {
		int staticAddress = finalCode.getMemorySize();

		List<SymbolIF> symbols = scope.getSymbolTable().getSymbols();
		for (SymbolIF symbol : symbols) {
			if (symbol instanceof SymbolVariable variable) {
				variable.setAddress(staticAddress);
				staticAddress -= variable.getType().getSize();
			}
		}

		List<TemporalIF> temporals = scope.getTemporalTable().getTemporals();
		for (TemporalIF temporal : temporals) {
			if (temporal instanceof Temporal t) {
				t.setAddress(staticAddress);
				staticAddress -= t.getSize();
			}
		}
	}

	for (ScopeIF scope : scopes) {
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		if (scope.getLevel() == 0) {
			List<SymbolIF> symbols = scope.getSymbolTable().getSymbols();
			for (SymbolIF symbol : symbols) {
				if (symbol instanceof SymbolVariable variable) {
					if (variable.getType().getName().equals("ENTERO") || variable.getType().getName().equals("LOGICO")) {
						Variable var = new Variable(variable.getName(), variable.getScope());
						cb.addQuadruple("VARGLOBAL", var, 0);
					} else {
						for (int i = 0; i < variable.getType().getSize(); i++) {
							Variable var = new Variable(variable.getName(), variable.getScope());
							int address = variable.getAddress() - i;
							cb.addQuadruple("VARGLOBALVECTOR", var, address, 0);
						}
					}
				}
			}
		}
		cb.addQuadruples(ax.getIntermediateCode());
		ax.setIntermediateCode(cb.create());
	}

	// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  	List intermediateCode = ax.getIntermediateCode();
  	finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
	finalCodeFactory.create(intermediateCode);

  	// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  	// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  	// aún no se tendrá implementada la generación de codigo intermedio ni final.
  	// Para la entrega final deberán descomentarse y usarse.
  		
  	syntaxErrorManager.syntaxInfo("Parsing process ended.");  	
:} ;

axiom ::= defprincipal:dprincipal {:
	AxiomImpl ax = new AxiomImpl();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());	
	cb.addQuadruples(dprincipal.getIntermediateCode());
	
	ax.setIntermediateCode(cb.create());

	RESULT = ax;
:} ;

epsilon ::= ;

// Definición de constantes
defconstantes ::= IDEN:id ASIGNACION valorconstante:vconstante DSENTENCIAS defconstantes:dconstantes {:
	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();

	// Se comprueba si la constante simbólica ya ha sido declarada.
	if (symbolTable.containsSymbol(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: constant " + name + " is already defined in " + currentScope.getName());
	}
	// Se comprueba si el identificador hace referencia a un tipo declarado.
	else if (scopeManager.containsType(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: expected identifier, but " + name + " found");
	} else {
		TypeIF type = scopeManager.searchType(vconstante.getType());
		SymbolConstant constant = null;

		// Se determina el tipo de la constante simbólica.
		if (type.getName().equals("ENTERO")) {
			constant = new SymbolConstantInteger(currentScope, name.toUpperCase(), type, Integer.parseInt(vconstante.getValue()));
		} else {
			constant = new SymbolConstantBoolean(currentScope, name.toUpperCase(), type, vconstante.getValue());
		}

		// Se añade informacion sobre la nueva constante simbolica y se inserta en la lista de constantes declaradas.
		symbolTable.addSymbol(constant);
		dconstantes.add(0, constant);

		RESULT = dconstantes;
	}
:} | epsilon {:
	// Se inicializa la lista de constantes declaradas.
	RESULT = new ArrayList<SymbolConstant>();
:} ;

valorconstante ::= FALSO:falso {:
	RESULT = new ValorConstante("LOGICO", falso.getLexema());
:} | CIERTO:cierto {:
	RESULT = new ValorConstante("LOGICO", cierto.getLexema());
:} | NUM:num {:
	RESULT = new ValorConstante("ENTERO", num.getLexema());
:} ;

seccionconstantes ::= BCONSTANTES defconstantes:dconstantes {:
	RESULT = dconstantes;
:} | epsilon ;

// Definición de tipos
deftipos ::= IDEN:id ASIGNACION DECLVECTOR CIZQUIERDO valorango:vrango1 RANGO valorango:vrango2 CDERECHO ASIGNACIONVECTOR tipovector:tvector DSENTENCIAS deftipos:dtipos {:
	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();

	if (symbolTable.containsSymbol(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: symbol " + name + " is already defined in " + currentScope.getName());
	}

	if (scopeManager.containsType(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: type " + name + " is already defined");
	}

	// Se comprueba que los valores de rango no vengan dados por variables.
	if (vrango1.getName() != null || vrango2.getName() != null) {
		semanticErrorManager.semanticFatalError("error: expected integer constant");
	}

	int firstIndex = vrango1.getValue();
	int lastIndex = vrango2.getValue();

	// Se comprueba que el indice inferior no sea mayor que el indice superior.
	if (lastIndex < firstIndex) {
		semanticErrorManager.semanticFatalError("error: last index must be greater than or equals to first index");
	}
	
	TypeTableIF typeTable = currentScope.getTypeTable();
	TypeArray arrayType = new TypeArray(currentScope, name.toUpperCase(), firstIndex, lastIndex, tvector);
	
	// Se añade informacion sobre el nuevo tipo y se inserta en la lista de tipos declarados.
	typeTable.addType(arrayType);
	dtipos.add(0, arrayType);

	RESULT = dtipos;
:} | epsilon {:
	// Se crea una lista vacia para los tipos declarados.
	RESULT = new ArrayList<TypeArray>();
:} ;

tipovector ::= BOOLEANO {:
	// Se obtiene el tipo primitivo booleano.
	RESULT = (TypeSimple)scopeManager.searchType("LOGICO");
:} | ENTERO {:
	// Se obtiene el tipo primitivo entero.
	RESULT = (TypeSimple)scopeManager.searchType("ENTERO");
:} ;

valorango ::= NUM:num {:
	int integerLiteral = Integer.parseInt(num.getLexema()) - 1;

	ValorRango vrango = new ValorRango(integerLiteral);
	vrango.setType(scopeManager.searchType("ENTERO"));

	RESULT = vrango;
:} | IDEN:id {:
	String name = id.getLexema();

	// Se comprueba si el identificador ha sido declarado previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());

		// Se comprueba si el identificador hace referencia a una constante simbolica entera.
		if (symbol instanceof SymbolConstantInteger constant) {
			RESULT = new ValorRango(constant.getValue(), scopeManager.searchType("ENTERO"));
		} else
		if (symbol instanceof SymbolVariable variable && variable.getType().getName().equals("ENTERO")) {
			RESULT = new ValorRango(variable.getName(), scopeManager.searchType("ENTERO"));
		} else {
			semanticErrorManager.semanticFatalError("error: expected constant or variable of type integer");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}
:} | miembrovector:mvector {:
	ValorRango vrango = new ValorRango();
	vrango.setType(mvector.getType());

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(mvector.getIntermediateCode());

	vrango.setTemporal(mvector.getTemporal());
	vrango.setIntermediateCode(cb.create());

	RESULT = vrango;
:} ;

secciontipos ::= COMIENZODECLTIPOS deftipos:dtipos {:
	RESULT = dtipos;
:} | epsilon ;

// Definición de variables
tipovariable ::= BOOLEANO {:
	RESULT = (TypeSimple)scopeManager.searchType("LOGICO");
:} | ENTERO {:
	RESULT = (TypeSimple)scopeManager.searchType("ENTERO");
:} | IDEN:id {:
	String name = id.getLexema();

	// Se comprueba que el tipo haya sido declarado previamente en cualquiera de los ambitos abiertos.
	if (scopeManager.containsType(name.toUpperCase())) {
		TypeIF type = scopeManager.searchType(name.toUpperCase());

		// Se comprueba que el tipo sea un tipo vector.
		if (type instanceof TypeArray arrayType) {
			RESULT = arrayType;
		} else {
			semanticErrorManager.semanticFatalError("error: array type required, but " + type.getName() + " found");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find type " + name);
	}
:} ;

selectorvalororeferencia ::= PARAMETROVALOR IDEN:id {:
	RESULT = new SelectorValorOReferencia(id.getLexema().toUpperCase());
:} | valorconstante:constante {:
	TypeIF type = scopeManager.searchType(constante.getType());

	SelectorValorOReferencia svor = new SelectorValorOReferencia(constante, type);
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF temp0 = temporalFactory.create();

	// Se obtiene el valor de la constante.
	Value constantValue = new Value(constante.getValue());

	cb.addQuadruple("MV", temp0, constantValue);
	cb.addQuadruple("PARAM", temp0);

	svor.setTemporal(temp0);
	svor.setIntermediateCode(cb.create());

	RESULT = svor;
:} | miembrovector:mvector {:
	SelectorValorOReferencia svor = new SelectorValorOReferencia(mvector);

	// Generacion del codigo intermedio.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

	cb.addQuadruples(mvector.getIntermediateCode());

	svor.setTemporal(mvector.getTemporal());
	svor.setIntermediateCode(cb.create());

	RESULT = svor;
:} | IDEN:id {:
	RESULT = new SelectorValorOReferencia(id.getLexema().toUpperCase());
:} ;

defvariables ::= listavariables:lvariables DELIMFUNC tipovariable:tvariable puntoycomaopcional defvariables:dvariables {:
	// Se establece el tipo de cada simbolo declarado.
	for (SelectorValorOReferencia symbol : lvariables) {
		symbol.setType(tvariable);
	}

	// Se añade la lista de variables al resto de variables declaradas.
	dvariables.addVariables(lvariables);

	RESULT = dvariables;
:} | epsilon {:
	// Se crea una lista vacia para las variables declaradas.
	RESULT = new DefVariables();
:} ;

listavariables ::= selectorvalororeferencia:svor DIDENTIFICADORES listavariables:lvariables {:
	// Se añade una nueva variable a la lista de variables.
	lvariables.add(0, svor);
	RESULT = lvariables;
:} | selectorvalororeferencia:svor {:
	// Se crea una lista de variables y se añade una variable.
	ArrayList<SelectorValorOReferencia> variableList = new ArrayList<>();
	variableList.add(svor);
	RESULT = variableList;
:} | epsilon {:
	// Se crea una lista vacia para las variables declaradas.
	RESULT = new ArrayList<SelectorValorOReferencia>();
:} ;

seccionvariables ::= DECLVARIABLES defvariables:dvariables {:
	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();
	ArrayList<SelectorValorOReferencia> variableList = dvariables.getVariables();

	for (SelectorValorOReferencia symbol : variableList) {
		String name = symbol.getName().toUpperCase();

		if ((symbolTable.containsSymbol(name)) | (scopeManager.containsType(name))) {
			semanticErrorManager.semanticFatalError("error: variable " + symbol.getName() + " is already defined in " + currentScope.getName());
		} else {
			symbolTable.addSymbol(new SymbolVariable(currentScope, name, symbol.getType()));
		}
	}
:} | epsilon ;

puntoycomaopcional ::= DSENTENCIAS | epsilon ;

// reglas de subprogramas
tiporetornofuncion ::= IDEN:id {:
	// Solo se permite que las funciones devuelvan un tipo basico.
	semanticErrorManager.semanticFatalError("error: integer or boolean required, but " + id.getLexema() + " found at line " + id.getLine());
:} | tipovector:tvector {:
	RESULT = tvector;
:} ;

procedimiento ::= COMIENZOPROCEDIMIENTO IDEN:id PIZQUIERDO defvariables:dvariables {:
	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();

	// Se comprueba que el procedimiento no haya sido declarado anteriormente.
	if (symbolTable.containsSymbol(name.toUpperCase()) || scopeManager.containsType(name.toUpperCase())) {
		semanticErrorManager.semanticFatalError("error: " + name + " is already defined");
	} else {
		TypeProcedure type = new TypeProcedure(currentScope, name.toUpperCase());
		SymbolProcedure procedure = new SymbolProcedure(currentScope, name.toUpperCase(), type);

		TypeTableIF typeTable = currentScope.getTypeTable();

		// Se inserta una entrada en las tablas de simbolos y tipos con informacion sobre el procedimiento.
		symbolTable.addSymbol(procedure);
		typeTable.addType(name.toUpperCase(), type);

		// Se crea el ambito asociado al procedimiento.
		scopeManager.openScope(name.toUpperCase());
		ScopeIF procedureScope = scopeManager.getCurrentScope();

		SymbolTableIF procedureSymbolTable = procedureScope.getSymbolTable();
		ArrayList<SelectorValorOReferencia> parameterList = dvariables.getVariables();

		// Se inserta una entrada en la tabla de simbolos con informacion de cada parámetro.
		for (SelectorValorOReferencia symbol : parameterList) {
			if (procedureSymbolTable.containsSymbol(symbol.getName().toUpperCase())) {
				semanticErrorManager.semanticFatalError("error: variable " + symbol.getName() + " is already defined");
			} else {
				SymbolParameter parameter = new SymbolParameter(procedureScope, symbol.getName().toUpperCase(), symbol.getType());
				type.addParameter(parameter);
				procedure.addParameter(parameter);
				procedureSymbolTable.addSymbol(parameter);
			}
		}
	}
:} PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS {:
	// Se cierra el ambito del procedimiento.
	scopeManager.closeScope();
:} ;

funcion ::= DECLAREFUNCION IDEN:id PIZQUIERDO defvariables:dvariables PDERECHO DELIMFUNC tiporetornofuncion:tretorno {:
	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();
	TypeTableIF typeTable = currentScope.getTypeTable();

	// Se comprueba que la funcion no haya sido declarada anteriormente.
	if ((symbolTable.containsSymbol(name.toUpperCase())) || (typeTable.containsType(name.toUpperCase()))) {
		semanticErrorManager.semanticFatalError("error: " + name + " is already defined");
	} else {
		TypeFunction type = new TypeFunction(currentScope, name.toUpperCase(), tretorno);
		SymbolFunction function = new SymbolFunction(currentScope, name.toUpperCase(), type, tretorno);

		// Se inserta una entrada en las tablas de simbolos y tipos con informacion sobre la funcion.
		symbolTable.addSymbol(function);
		typeTable.addType(type.getName().toUpperCase(), type);

		// Creacion del ambito asociado a la funcion.
		scopeManager.openScope(name.toUpperCase());
		ScopeIF functionScope = scopeManager.getCurrentScope();

		// Se inserta una entrada en la tabla de simbolos con informacion de cada parametro en la lista de parametros de la funcion.
		SymbolTableIF functionSymbolTable = functionScope.getSymbolTable();
		ArrayList<SelectorValorOReferencia> parameterList = dvariables.getVariables();

		for (SelectorValorOReferencia symbol : parameterList) {
			if (functionSymbolTable.containsSymbol(symbol.getName().toUpperCase())) {
				semanticErrorManager.semanticFatalError("error: variable " + symbol.getName() + " is already defined");
			} else {
				SymbolParameter parameter = new SymbolParameter(functionScope, symbol.getName().toUpperCase(), symbol.getType());
				type.addParameter(parameter);
				function.addParameter(parameter);
				functionSymbolTable.addSymbol(parameter);
			}
		}
	}
:} DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion {:
	SymbolFunction function = (SymbolFunction)scopeManager.searchSymbol(scopeManager.getCurrentScope().getName());

	// Se comprueba que al menos existe una sentencia devolver en la funcion.
	if (function.hasReturnStatement()) {
		scopeManager.closeScope();
	} else {
		semanticErrorManager.semanticFatalError("error: missing devolver statement in function " + function.getName());
	}
:} FINBLOQUESENTENCIAS DSENTENCIAS ;

selectorpof ::= procedimiento | funcion ;

defsubprograma ::= selectorpof defsubprograma | epsilon ;

seccionsubprograma ::= COMIENZOSUBPROGRAMAS defsubprograma | epsilon ;

// Definición del programa principal

defprincipal ::= COMIENZOPROGRAMA IDEN:id {:
	String name = id.getLexema();

	// Creacion del ambito global con el nombre del programa principal.
	scopeManager.openScope(name.toUpperCase());

	ScopeIF currentScope = scopeManager.getCurrentScope();
	TypeTableIF typeTable = currentScope.getTypeTable();

	// Se introducen los tipos primitivos del lenguaje en la tabla de tipos del ambito global.
	typeTable.addType("ENTERO", new TypeSimple(currentScope, "ENTERO"));
	typeTable.addType("LOGICO", new TypeSimple(currentScope, "LOGICO"));
:} DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias:lsentencias {:
	DefPrincipal dprincipal = new DefPrincipal();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(lsentencias.getIntermediateCode());
	cb.addQuadruple("HALT");
	cb.addQuadruples(strings);

	dprincipal.setIntermediateCode(cb.create());

	RESULT = dprincipal;
:} FINBLOQUESENTENCIAS FINPROGRAMA ;

expresion ::= expresion:leftExpression MENORQUE expresion:rightExpression {:
	String leftExpressionTypeName = leftExpression.getType().getName();
	String rightExpressionTypeName = rightExpression.getType().getName();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador '<' y entre si.
	if (leftExpressionTypeName.equals("ENTERO")) {
		if (leftExpressionTypeName.equals(rightExpressionTypeName)) {
			Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("LOGICO"));
			ScopeIF currentScope = scopeManager.getCurrentScope();

			// Generacion del codigo intermedio para la expresion menor que.
			TemporalFactory temporalFactory = new TemporalFactory(currentScope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

			TemporalIF leftExpressionTemporal = leftExpression.getTemporal();
			TemporalIF rightExpressionTemporal = rightExpression.getTemporal();
			TemporalIF resultTemporal = temporalFactory.create();

			cb.addQuadruples(leftExpression.getIntermediateCode());
			cb.addQuadruples(rightExpression.getIntermediateCode());
			cb.addQuadruple("LS", resultTemporal, leftExpressionTemporal, rightExpressionTemporal);

			expression.setTemporal(resultTemporal);
			expression.setIntermediateCode(cb.create());

			RESULT = expression;
		} else {
			semanticErrorManager.semanticFatalError("error: incomparable types: " + leftExpressionTypeName + " and " + rightExpressionTypeName);
		}
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand types for binary operator '<'");
	}
:} | expresion:leftExpression IGUALDAD expresion:rightExpression {:
	// Se recupera el nombre del tipo de las subexpresiones.
	String leftExpressionType = leftExpression.getType().getName();
	String rightExpressionType = rightExpression.getType().getName();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador '=='.
	if (leftExpressionType.equals(rightExpressionType)) {
		Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("LOGICO"));
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para expresiones de igualdad.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftExpressionTemp = leftExpression.getTemporal();
		TemporalIF rightExpressionTemp = rightExpression.getTemporal();
		TemporalIF expressionTemp = temporalFactory.create();

		cb.addQuadruples(leftExpression.getIntermediateCode());
		cb.addQuadruples(rightExpression.getIntermediateCode());
		cb.addQuadruple("EQ", expressionTemp, leftExpressionTemp, rightExpressionTemp);

		expression.setTemporal(expressionTemp);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: incomparable types: " + leftExpressionType + " and " + rightExpressionType);
	}
:} | IDEN:id {:
	String name = id.getLexema();

	// Se comprueba que el identificador haya sido declarado previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());

		Expresion expression = new Expresion(name, symbol.getType());
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para expresiones con identificadores.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF identifierTemporal = temporalFactory.create();

		// Se obtiene el valor del simbolo cuando se trata de una constante simbolica.
		if (symbol instanceof SymbolConstantInteger constant) {
			Value constantValue = new Value(constant.getValue());
			cb.addQuadruple("MV", identifierTemporal, constantValue);
		} else if (symbol instanceof SymbolConstantBoolean constant) {
			Value constantValue = new Value(constant.getValue());
			cb.addQuadruple("MV", identifierTemporal, constantValue);
		}
		// en cualquier otro caso se obtiene su identificador y su ambito de definicion.
		else if ((symbol instanceof SymbolVariable) || (symbol instanceof SymbolParameter)) {
			Variable variable = new Variable(name.toUpperCase(), symbol.getScope());
			cb.addQuadruple("MVP", identifierTemporal, variable);
		} else {
			semanticErrorManager.semanticFatalError("error: constant or variable expected, but " + symbol.getClass().getName() + " found");
		}

		expression.setTemporal(identifierTemporal);
		expression.setIntermediateCode(cb.create());
		
		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}
:} | llamadafuncion:lfuncion {:
	TypeIF type = scopeManager.searchType(lfuncion.getName().toUpperCase());

	// Se comprueba que la invocacion de la funcion se realiza en el contexto de una expresion.
	if (type instanceof TypeFunction functionType) {
		Expresion expression = new Expresion(functionType.getReturnType());
		ScopeIF currentScope = scopeManager.getCurrentScope();

		TemporalFactory temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF temp = temporalFactory.create();

		cb.addQuadruple("MV", temp, new Value(0));

		expression.setTemporal(temp);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: expected function, but procedure found");
	}
:} | CIERTO:cierto {:
	Expresion expression = new Expresion(scopeManager.searchType("LOGICO"));
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para el valor logico cierto.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF expressionTemporal = temporalFactory.create();

	cb.addQuadruple("MV", expressionTemporal, new Value(1));

	expression.setTemporal(expressionTemporal);
	expression.setIntermediateCode(cb.create());

	RESULT = expression;
:} | FALSO:falso {:
	Expresion expression = new Expresion(scopeManager.searchType("LOGICO"));
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para el valor logico falso.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF expressionTemporal = temporalFactory.create();

	cb.addQuadruple("MV", expressionTemporal, new Value(0));

	expression.setTemporal(expressionTemporal);
	expression.setIntermediateCode(cb.create());

	RESULT = expression;
:} | miembrovector:mvector {:
	Expresion expression = new Expresion(mvector.getName(), ((TypeArray)mvector.getType()).getBaseType());
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para la expresion de acceso a vector.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF expressionTemporal = temporalFactory.create();

	cb.addQuadruples(mvector.getIntermediateCode());
	cb.addQuadruple("MVP", expressionTemporal, mvector.getTemporal());

	expression.setTemporal(expressionTemporal);
	expression.setIntermediateCode(cb.create());

	RESULT = expression;
:} | NUM:num {:
	Expresion expression = new Expresion(scopeManager.searchType("ENTERO"));
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para un valor entero.
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	TemporalIF expressionTemporal = temporalFactory.create();

	Value integerValue = new Value(Integer.parseInt(num.getLexema()));

	cb.addQuadruple("MV", expressionTemporal, integerValue);

	expression.setTemporal(expressionTemporal);
	expression.setIntermediateCode(cb.create());

	RESULT = expression;
:} | expresionlvl2:expression2 {:
	Expresion expression = new Expresion(expression2, expression2.getType());

	// Generacion del codigo intermedio para expresiones de nivel 1.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression2.getIntermediateCode());

	expression.setTemporal(expression2.getTemporal());
	expression.setIntermediateCode(cb.create());

	RESULT = expression;
:} ;

expresionlvl2 ::= expresion:leftExpression SUMA expresion:rightExpression {:
	// Se recupera el tipo de las subexpresiones.
	TypeIF leftExpressionType = leftExpression.getType();
	TypeIF rightExpressionType = rightExpression.getType();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador '+'.
	if (leftExpressionType.getName().equals("ENTERO") && leftExpressionType.getName().equals(rightExpressionType.getName())) {
		Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("ENTERO"));
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la expresion de suma.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftExpressionTemporal = leftExpression.getTemporal();
		TemporalIF rightExpressionTemporal = rightExpression.getTemporal();
		TemporalIF expressionTemporal = temporalFactory.create();

		cb.addQuadruples(leftExpression.getIntermediateCode());
		cb.addQuadruples(rightExpression.getIntermediateCode());
		cb.addQuadruple("ADD", expressionTemporal, leftExpressionTemporal, rightExpressionTemporal);

		expression.setTemporal(expressionTemporal);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand types for binary operator '+'");
	}
:} | expresionlvl3:expression3 {:
	Expresion expression = new Expresion(expression3, expression3.getType());

	// Generacion del codigo intermedio para expresiones de nivel 2.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression3.getIntermediateCode());

	expression.setTemporal(expression3.getTemporal());
	expression.setIntermediateCode(cb.create());

	RESULT = expression;
:} ;

expresionlvl3 ::= expresion:leftExpression YLOGICA expresion:rightExpression {:
	// Se recupera el tipo de las subexpresiones.
	TypeIF leftExpressionType = leftExpression.getType(), rightExpressionType = rightExpression.getType();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador 'y'.
	if (leftExpressionType.getName().equals("LOGICO") && leftExpressionType.getName().equals(rightExpressionType.getName())) {
		Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("LOGICO"));
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la expresion logica AND.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftExpressionTemporal = leftExpression.getTemporal();
		TemporalIF rightExpressionTemporal = rightExpression.getTemporal();
		TemporalIF expressionTemporal = temporalFactory.create();

		cb.addQuadruples(leftExpression.getIntermediateCode());
		cb.addQuadruples(rightExpression.getIntermediateCode());
		cb.addQuadruple("AND", expressionTemporal, leftExpressionTemporal, rightExpressionTemporal);

		expression.setTemporal(expressionTemporal);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand types for binary operator 'y'");
	}
:} | expresion:leftExpression PRODUCTO expresion:rightExpression {:
	// Se recupera el tipo de las subexpresiones.
	TypeIF leftExpressionType = leftExpression.getType(), rightExpressionType = rightExpression.getType();

	// Se comprueba que el tipo de las subexpresiones sea compatible con el operador '*'.
	if (leftExpressionType.getName().equals("ENTERO") && leftExpressionType.getName().equals(rightExpressionType.getName())) {
		Expresion expression = new Expresion(leftExpression, rightExpression, scopeManager.searchType("ENTERO"));
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la expresion de multiplicación.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftExpressionTemporal = leftExpression.getTemporal();
		TemporalIF rightExpressionTemporal = rightExpression.getTemporal();
		TemporalIF expressionTemporal = temporalFactory.create();

		cb.addQuadruples(leftExpression.getIntermediateCode());
		cb.addQuadruples(rightExpression.getIntermediateCode());
		cb.addQuadruple("MUL", expressionTemporal, leftExpressionTemporal, rightExpressionTemporal);

		expression.setTemporal(expressionTemporal);
		expression.setIntermediateCode(cb.create());

		RESULT = expression;
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand types for binary operator '*'");
	}
:} | expresionlvl4:expression4 {:
	Expresion expression = new Expresion(expression4, expression4.getType());

	// Generacion del codigo intermedio para expresiones de nivel 3.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression4.getIntermediateCode());

	expression.setTemporal(expression4.getTemporal());
	expression.setIntermediateCode(cb.create());

	RESULT = expression;
:} ;

expresionlvl4 ::= NOLOGICO expresion:expression {:
	// Se recupera el tipo de las subexpresiones.
	TypeIF expressionType = expression.getType();

	// Se comprueba que el tipo de la subexpresion sea compatible con el operador 'no'.
	if (expressionType.getName().equals("LOGICO")) {
		Expresion expression4 = new Expresion(expression, expressionType);
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la expresion logica NOT.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF expressionTemporal = expression.getTemporal();
		TemporalIF notExpressionTemporal = temporalFactory.create();

		cb.addQuadruples(expression.getIntermediateCode());
		cb.addQuadruple("NOT", notExpressionTemporal, expressionTemporal);

		expression4.setTemporal(notExpressionTemporal);
		expression4.setIntermediateCode(cb.create());

		RESULT = expression4;
	} else {
		semanticErrorManager.semanticFatalError("error: bad operand type for unary operator 'no'");
	}
:} | expresionlvl5:expression5 {:
	Expresion expression = new Expresion(expression5, expression5.getType());

	// Generacion del codigo intermedio para expresiones de nivel 4.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression5.getIntermediateCode());

	expression.setTemporal(expression5.getTemporal());
	expression.setIntermediateCode(cb.create());

	RESULT = expression;
:} ;

expresionlvl5 ::= PIZQUIERDO expresion:expression PDERECHO {:
	Expresion expression5 = new Expresion(expression, expression.getType());

	// Generacion del codigo intermedio para expresiones entre parentesis.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression.getIntermediateCode());	// CI de la expresion

	expression5.setTemporal(expression.getTemporal());
	expression5.setIntermediateCode(cb.create());

	RESULT = expression5;
:} | CIZQUIERDO expresion:expression CDERECHO {:
	Expresion expression5 = new Expresion(expression, expression.getType());

	// Generacion del codigo intermedio para expresiones entre corchetes.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression.getIntermediateCode());

	expression5.setTemporal(expression.getTemporal());
	expression5.setIntermediateCode(cb.create());

	RESULT = expression5;
:} ;

// Acceso a vectores
miembrovector ::= IDEN:id CIZQUIERDO valorango:vrango CDERECHO {:
	String name = id.getLexema();

	ScopeIF currentScope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = currentScope.getSymbolTable();

	// Se comprueba que el identificador haya sido declarado previamente.
	if (symbolTable.containsSymbol(name.toUpperCase())) {
		SymbolIF identifier = symbolTable.getSymbol(name.toUpperCase());
		TypeIF identifierType = identifier.getType();

		// Se comprueba que el tipo del identificador sea tipo vector.
		if (identifierType instanceof TypeArray arrayType) {
			TypeIF rangeValueType = vrango.getType();

			// Si el valor del rango es de tipo vector se propaga el codigo intermedio asociado a el.
			if (rangeValueType instanceof TypeArray t) {
				// Se comprueba que el tipo de los elementos del valor del rango sea entero.
				if (t.getBaseType().getName().equals("ENTERO")) {
					MiembroVector vector = new MiembroVector(name.toUpperCase(), arrayType);

					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);
					cb.addQuadruples(vrango.getIntermediateCode());

					vector.setTemporal(vrango.getTemporal());
					vector.setIntermediateCode(cb.create());

					RESULT = vector;
				} else {
					semanticErrorManager.semanticFatalError("error: the index for the vector must be of type integer");
				}
			} else
			// Se comprueba si el valor del rango es de tipo entero.
			if (rangeValueType.getName().equals("ENTERO")) {
				// Si el valor del rango viene dado por una variable se obtiene su direccion de memoria.
				if (vrango.getName() != null) {
					SymbolIF variable = (SymbolVariable)scopeManager.searchSymbol(vrango.getName());
					
					MiembroVector vector = new MiembroVector(name.toUpperCase(), arrayType);

					TemporalFactory temporalFactory = new TemporalFactory(currentScope);
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

					TemporalIF effectiveAddress = temporalFactory.create();
					TemporalIF baseAddress = temporalFactory.create();
					TemporalIF offset = temporalFactory.create();
					TemporalIF newOffset = temporalFactory.create();

					Variable identifierVariable = new Variable(name.toUpperCase(), variable.getScope());
					Variable rangeValueVariable = new Variable(variable.getName(), variable.getScope());

					cb.addQuadruple("MVP", offset, rangeValueVariable);
					cb.addQuadruple("DEC", offset);
					cb.addQuadruple("MVA", baseAddress, identifierVariable);
					cb.addQuadruple("SUB", effectiveAddress, baseAddress, offset);

					vector.setTemporal(effectiveAddress);
					vector.setIntermediateCode(cb.create());

					RESULT = vector;
				} 
				// En cualquier otro caso el valor del rango sera un numero entero y se obtendra su valor.
				else {
					// Se comprueba que el valor dado se encuentre dentro del rango del vector.
					if (vrango.getValue() <= arrayType.getSize()) {
						MiembroVector vector = new MiembroVector(name.toUpperCase(), arrayType);

						// Generacion del codigo intermedio para el acceso a vectores.
						TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

						TemporalIF effectiveAddress = temporalFactory.create();
						TemporalIF baseAddress = temporalFactory.create();
						TemporalIF offset = temporalFactory.create();

						Value rangeValue = new Value(vrango.getValue());

						Variable identifierVariable = new Variable(name.toUpperCase(), identifier.getScope());

						cb.addQuadruple("MV", offset, rangeValue);
						cb.addQuadruple("MVA", baseAddress, identifierVariable);
						cb.addQuadruple("SUB", effectiveAddress, baseAddress, offset);

						vector.setTemporal(effectiveAddress);
						vector.setIntermediateCode(cb.create());

						RESULT = vector;
					} else {
						semanticErrorManager.semanticFatalError("error: index " + vrango.getValue() + " out of bounds for length " + arrayType.getSize());
					}
				}
			}
		} else {
			semanticErrorManager.semanticFatalError("error: array required, but " + identifierType.getName() + " found");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}
:} ;
 
// Sentencias de asignacion
parteizquierdaasignacion ::= IDEN:id {:
	String name = id.getLexema().toUpperCase();

	// Se comprueba si el identificador ha sido declarado previamente.
	if (scopeManager.containsSymbol(name)) {
		SymbolIF symbol = scopeManager.searchSymbol(name);

		// Se genera un error en caso de que el simbolo sea una constante simbolica.
		if (symbol instanceof SymbolConstant) {
			semanticErrorManager.semanticFatalError("error: cannot assign a value to constant " + id.getLexema() + " at line " + id.getLine());
		} else if (symbol.getType().getName().equals(name)) {
			semanticErrorManager.semanticFatalError("error: cannot assign an array directly.");
		}
		// Si el simbolo es una variable se obtiene la direccion de memoria en la que esta almacenada.
		else if (symbol instanceof SymbolVariable || symbol instanceof SymbolParameter) {
			TypeIF variableType = symbol.getType();
			ParteIzquierdaAsignacion leftSide = new ParteIzquierdaAsignacion(name, symbol.getType());
			ScopeIF currentScope = scopeManager.getCurrentScope();

			// Generacion del codigo intermedio para la parte izquierda de una sentencia de asignacion.
			TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

			TemporalIF identifierTemporal = temporalFactory.create();

			Variable identifierVariable = new Variable(name, symbol.getScope());

			cb.addQuadruple("MVA", identifierTemporal, identifierVariable);		// Temporal := &variable

			leftSide.setTemporal(identifierTemporal);
			leftSide.setIntermediateCode(cb.create());

			RESULT = leftSide;
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + id.getLexema() + " at line " + id.getLine());
	}
:} | miembrovector:vector {:
	ParteIzquierdaAsignacion leftSide = new ParteIzquierdaAsignacion(vector.getName(), ((TypeArray)vector.getType()).getBaseType());

	// Generacion del codigo intermedio para la parte izquierda de una sentencia de asignacion.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(vector.getIntermediateCode());

	leftSide.setTemporal(vector.getTemporal());
	leftSide.setIntermediateCode(cb.create());

	RESULT = leftSide;
:} ;

sentenciadeasignacion ::= parteizquierdaasignacion:leftSide ASIGNACION parametroasignacion:assignParameter {:
	// Se comprueba que el tipo en la parte izquierda coincide con el tipo en la parte derecha.
	if (leftSide.getType().getName().equals(assignParameter.getType().getName())) {
		SentenciaDeAsignacion sasignacion = new SentenciaDeAsignacion();
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para la sentencia de asignacion.
		TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF leftSideTemporal = leftSide.getTemporal();
		TemporalIF assignParameterTemporal = assignParameter.getTemporal();

		cb.addQuadruples(assignParameter.getIntermediateCode());
		cb.addQuadruples(leftSide.getIntermediateCode());
		cb.addQuadruple("STP", leftSideTemporal, assignParameterTemporal);

		sasignacion.setIntermediateCode(cb.create());

		RESULT = sasignacion;
	} else {
		semanticErrorManager.semanticFatalError("error: incompatible types: " + assignParameter.getType().getName() + " cannot be converted to " + leftSide.getType().getName());
	}
:} DSENTENCIAS ;

parametroasignacion ::= expresion:expression {:
	ParametroAsignacion assignParameter = new ParametroAsignacion(expression);

	// Generacion del codigo intermedio para la expresion en la parte derecha de la sentencia de asignacion.
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(expression.getIntermediateCode());

	assignParameter.setTemporal(expression.getTemporal());
	assignParameter.setIntermediateCode(cb.create());

	RESULT = assignParameter;
:} ;

// Llamada a funcion
parametrofuncionoproc ::= listavariables:variables {:
	RESULT = new ListaParametros(variables);
:} ;

llamadafuncion ::= IDEN:id PIZQUIERDO parametrofuncionoproc:parameters {:
	String name = id.getLexema();

	// Se comprueba que el identificador haya sido declarado previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());

		// Se comprueba que el identificador haga referencia a un subprograma.
		if (symbol instanceof SymbolProcedure procedure) {
			ArrayList<SelectorValorOReferencia> actualParams = parameters.getParameters();
			ArrayList<SymbolParameter> formalParams = procedure.getParameters();

			// Se comprueba que el numero de parametros actuales coincide con el numero de parametros formales.
			if (actualParams.size() == formalParams.size()) {
				Iterator<SelectorValorOReferencia> it1 = actualParams.iterator();
				Iterator<SymbolParameter> it2 = formalParams.iterator();
				SymbolTableIF symbolTable = scopeManager.getCurrentScope().getSymbolTable();

				while (it1.hasNext() && it2.hasNext()) {
					SelectorValorOReferencia svor = it1.next();
					SymbolParameter formalParam = it2.next();

					// Se comprueba si el parametro actual es un elemento de un vector.
					if ((svor.getName() != null) && (svor.getValue() != "")) {
						SymbolIF actualParam = symbolTable.getSymbol(svor.getName());
						TypeArray actualParamType = (TypeArray)actualParam.getType();

						if (!(actualParamType.getBaseType().getName().equals(formalParam.getType().getName()))) {
							semanticErrorManager.semanticFatalError("error: incompatible types: " + actualParamType.getBaseType().getName() + " cannot be converted to " + formalParam.getType().getName());
						}
					} else {
						if (svor.getName() == null) {
							if (!(svor.getType().getName().equals(formalParam.getType().getName()))) {
								semanticErrorManager.semanticFatalError("error: incompatible types: " + svor.getType().getName() + " cannot be converted to " + formalParam.getType().getName());
							}
						} else if (svor.getValue() == "") {
							SymbolIF actualParam = symbolTable.getSymbol(svor.getName());
							if (!(actualParam.getType().getName().equals(formalParam.getType().getName()))) {
								semanticErrorManager.semanticFatalError("error: incompatible types: " + actualParam.getType().getName() + " cannot be converted to " + formalParam.getType().getName());
							}
						}
					}
				}

				RESULT = new LlamadaFuncion(name, procedure.getType(), actualParams);
			} else {
				semanticErrorManager.semanticFatalError("error: actual and formal argument lists differ in length");
			}
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}
:} PDERECHO ;

sentenciallamadafuncion ::= llamadafuncion:lfuncion {:
	// Se comprueba que la llamada a funcion se realiza en el contexto de una sentencia.
	if (scopeManager.searchSymbol(lfuncion.getName()) instanceof SymbolFunction) {
		semanticErrorManager.semanticFatalError("error: expected procedure, but function found");
	}
:} DSENTENCIAS ;

// Sentencias
sentencia ::= sentenciadeasignacion:sasignacion {:
	Sentencia statement = new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(sasignacion.getIntermediateCode());

	statement.setIntermediateCode(cb.create());

	RESULT = statement;
:} | sentenciaif:sif {:
	Sentencia statement = new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(sif.getIntermediateCode());

	statement.setIntermediateCode(cb.create());

	RESULT = statement;
:} | sentenciafor:sfor {:
	Sentencia statement = new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(sfor.getIntermediateCode());

	statement.setIntermediateCode(cb.create());

	RESULT = statement;
:} | sentenciaEscribir:sescribir {:
	Sentencia statement = new Sentencia();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(sescribir.getIntermediateCode());

	statement.setIntermediateCode(cb.create());

	RESULT = statement;
:} | sentenciallamadafuncion ;

sentenciaFuncion ::= sentenciadeasignacion | sentenciaifFuncion | sentenciaforFuncion | sentenciaEscribir | sentenciallamadafuncion | sentenciaDevolver ;

listaSentencias ::= sentencia:statement listaSentencias:statements {:
	ScopeIF currentScope = scopeManager.getCurrentScope();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	if (statement != null)
		cb.addQuadruples(statement.getIntermediateCode());

	cb.addQuadruples(statements.getIntermediateCode());

	statements.setIntermediateCode(cb.create());
	statements.add(statement);

	RESULT = statements;
:} | epsilon {:
	// Se inicializa la lista de sentencias.
	RESULT = new ListaSentencias();
:} ;

listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion | epsilon ;

// if
sentenciaif ::= COMIENZOSI expresion:expression STARTIF DELIMFUNC listaSentencias:statements rellenoif:rif {:
	String expressionTypeName = expression.getType().getName();

	// Se comprueba que el tipo de la expresion a evaluar sea logico.
	if (expressionTypeName.equals("LOGICO")) {
		SentenciaIf sif = new SentenciaIf();
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para sentencias condicionales si-sino.
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);
		LabelFactoryIF labelFactory = new LabelFactory();

		TemporalIF expressionTemporal = expression.getTemporal();

		LabelIF elseLabel = labelFactory.create();
		LabelIF endIfLabel = labelFactory.create();

		cb.addQuadruples(expression.getIntermediateCode());
		cb.addQuadruple("BRF", expressionTemporal, elseLabel);
		cb.addQuadruples(statements.getIntermediateCode());
		cb.addQuadruple("BR", endIfLabel);
		cb.addQuadruple("INL", elseLabel);
		cb.addQuadruples(rif.getIntermediateCode());
		cb.addQuadruple("INL", endIfLabel);

		sif.setIntermediateCode(cb.create());

		RESULT = sif;
	} else {
		semanticErrorManager.semanticFatalError("error: incompatible types: " + expressionTypeName + " cannot be converted to LOGICO");
	}
:} FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;

sentenciaifFuncion ::= COMIENZOSI expresion:expression STARTIF DELIMFUNC listaSentenciasFuncion:statements rellenoifFuncion {:
	String expressionTypeName = expression.getType().getName();

	// Se comprueba que el tipo de la expresion a evaluar sea logico.
	if (!expressionTypeName.equals("LOGICO")) {
		semanticErrorManager.semanticFatalError("error: incompatible types: " + expressionTypeName + " cannot be converted to LOGICO");
	}
:} FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;

rellenoifFuncion ::= ALTERNATIVASI DELIMFUNC listaSentenciasFuncion | epsilon ;

rellenoif ::= ALTERNATIVASI DELIMFUNC listaSentencias:statements {:
	RellenoIf rif = new RellenoIf();

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(statements.getIntermediateCode());

	rif.setIntermediateCode(cb.create());

	RESULT = rif;
:} | epsilon ;

// for
sentenciafor ::= COMIENZOBUCLEPARA IDEN:id RANGOBUCLEPARA expresion:startExpression RANGO expresion:endExpression DELIMFUNC listaSentencias:statements {:
	String name = id.getLexema();

	// Se comprueba que la variable indice haya sido declarada previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		// Se comprueba que las expresiones que delimitan el rango sean de tipo entero.
		if (startExpression.getType().equals(scopeManager.searchType("ENTERO"))) {
			if (endExpression.getType().equals(scopeManager.searchType("ENTERO"))) {
				SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());
				
				// Se obtiene el identificador y ambito de declaracion del indice si se trata de una variable.
				if (symbol instanceof SymbolVariable variable) {
					Variable indexVariable = new Variable(name.toUpperCase(), variable.getScope());
					ScopeIF currentScope = scopeManager.getCurrentScope();
					
					SentenciaFor sfor = new SentenciaFor();
					
					// Generacion del codigo intermedio para la sentencia iterativa para.
					LabelFactory labelFactory = new LabelFactory();
					TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

					TemporalIF identifierTemporal = temporalFactory.create();

					LabelIF startLabel = labelFactory.create();
					LabelIF endLabel = labelFactory.create();

					TemporalIF indexAddress = temporalFactory.create();
					TemporalIF indexPointer = temporalFactory.create();
					TemporalIF resultTemporal = temporalFactory.create();
					
					// Se inicializa la variable indice
					cb.addQuadruples(startExpression.getIntermediateCode());
					cb.addQuadruple("MVA", indexAddress, indexVariable);
					cb.addQuadruple("STP", indexAddress, startExpression.getTemporal());

					cb.addQuadruples(endExpression.getIntermediateCode());
					cb.addQuadruple("INC", endExpression.getTemporal());

					// Se inserta la etiqueta de comienzo del bucle.
					cb.addQuadruple("INL", startLabel);
					
					cb.addQuadruple("MVP", indexPointer, indexVariable);

					// Se compara el valor de la variable indice con la expresion final.
					cb.addQuadruple("LS", resultTemporal, indexPointer, endExpression.getTemporal());

					// Salto a la etiqueta de fin del bucle si no se cumple la condicion.
					cb.addQuadruple("BRF", resultTemporal, endLabel);
					// Sentencias dentro del cuerpo del bucle
					cb.addQuadruples(statements.getIntermediateCode());

					// Se incrementa en uno el valor de la variable indice.
					cb.addQuadruple("INC", indexVariable);

					cb.addQuadruple("BR", startLabel);
					cb.addQuadruple("INL", endLabel);

					sfor.setIntermediateCode(cb.create());

					RESULT = sfor;
				} else {
					semanticErrorManager.semanticFatalError("error: variable expected, but " + symbol.getClass().getName() + " found");
				}
			} else {
				semanticErrorManager.semanticFatalError("error: the final value of the index must be an integer");
			}
		} else {
			semanticErrorManager.semanticFatalError("error: the initial value of the index must be an integer");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}
:} FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS ;

sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN:id RANGOBUCLEPARA expresion:startExpression RANGO expresion:endExpression DELIMFUNC listaSentenciasFuncion {:
	String name = id.getLexema();

	// Se comprueba que la variable indice haya sido declarada previamente.
	if (scopeManager.containsSymbol(name.toUpperCase())) {
		SymbolIF symbol = scopeManager.searchSymbol(name.toUpperCase());

		// Se comprueba si el indice se trata de una variable.
		if (!(symbol instanceof SymbolVariable variable)) {
			semanticErrorManager.semanticFatalError("error: variable expected, but " + symbol.getClass().getName() + " found");
		}
	} else {
		semanticErrorManager.semanticFatalError("error: cannot find symbol " + name + " at line " + id.getLine());
	}
	// Se comprueba que las expresiones que delimitan el rango sean de tipo entero.
	if (!startExpression.getType().equals(scopeManager.searchType("ENTERO"))) {
		semanticErrorManager.semanticFatalError("error: the initial value of the index must be an integer");
	}
	if (!endExpression.getType().equals(scopeManager.searchType("ENTERO"))) {
		semanticErrorManager.semanticFatalError("error: the final value of the index must be an integer");
	}
:} FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS ;

// escribir.
parametroEscribir ::= STRING:string {:
	ParametroEscribir pescribir = new ParametroEscribir();
	ScopeIF currentScope = scopeManager.getCurrentScope();

	// Generacion del codigo intermedio para imprimir cadenas.
	LabelFactoryIF labelFactory = new LabelFactory();
	TemporalFactoryIF temporalFactory = new TemporalFactory(currentScope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

	LabelIF stringLabel = labelFactory.create();

	TemporalIF stringTemporal = temporalFactory.create();

	Value stringValue = new Value(string.getLexema());

	cb.addQuadruple("WRITESTRING", stringTemporal, stringLabel);

	// Se almacena la cadena de caracteres para recuperar al final del programa principal.
	strings.add(new Quadruple("CADENA", new Label(string.getLexema()), stringLabel));

	pescribir.setTemporal(stringTemporal);
	pescribir.setIntermediateCode(cb.create());

	RESULT = pescribir;
:} | expresion:expression {:
	// Se comprueba que la expresion sea de tipo entero.
	if (expression.getType().getName().equals("ENTERO")) {
		ParametroEscribir pescribir = new ParametroEscribir();
		ScopeIF currentScope = scopeManager.getCurrentScope();

		// Generacion del codigo intermedio para imprimir expresiones enteras.
		TemporalFactory temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF expressionTemporal = expression.getTemporal();

		cb.addQuadruples(expression.getIntermediateCode());
		cb.addQuadruple("WRITEINT", expressionTemporal);

		pescribir.setTemporal(expressionTemporal);
		pescribir.setIntermediateCode(cb.create());

		RESULT = pescribir;
	} else {
		semanticErrorManager.semanticFatalError("error: incompatible types: expression must be of type entero");
	}
:} | epsilon {:
	ParametroEscribir pescribir = new ParametroEscribir();
	
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruple("WRITELN");

	pescribir.setIntermediateCode(cb.create());

	RESULT = pescribir;
:} ;

sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir:pescribir {:
	SentenciaEscribir sescribir = new SentenciaEscribir(pescribir);

	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(pescribir.getIntermediateCode());

	sescribir.setIntermediateCode(cb.create());

	RESULT = sescribir;
:} PDERECHO DSENTENCIAS ;

// devolver
sentenciaDevolver ::= FRETURN expresion:expression {:
	ScopeIF currentScope = scopeManager.getCurrentScope();
	ScopeIF parentScope = scopeManager.getParentScope();

	SymbolFunction function = (SymbolFunction)parentScope.getSymbolTable().getSymbol(currentScope.getName().toUpperCase());

	TypeIF expressionType = expression.getType();

	String expressionTypeName = expressionType.getName();
	String returnTypeName = function.getReturnType().getName();

	// Se comprueba que el tipo de la expresion a devolver coincida con el tipo de retorno de la funcion.
	if (expressionTypeName.equals(returnTypeName)) {
		function.hasReturnStatement(true);

		SentenciaDevolver returnStatement = new SentenciaDevolver(expression, expressionType);

		// Generacion del codigo intermedio para la sentencia devolver.
		LabelFactory labelFactory = new LabelFactory();
		TemporalFactory temporalFactory = new TemporalFactory(currentScope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);

		TemporalIF expressionTemporal = expression.getTemporal();

		LabelIF returnLabel = labelFactory.create("F" + currentScope.getName());

		cb.addQuadruples(expression.getIntermediateCode());
		cb.addQuadruple("RET", returnLabel, expressionTemporal);

		returnStatement.setIntermediateCode(cb.create());

		RESULT = returnStatement;
	} else {
		semanticErrorManager.semanticFatalError("error: incompatible types: " + expressionTypeName + " cannot be converted to " + returnTypeName);
	}
:} DSENTENCIAS ;